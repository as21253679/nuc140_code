; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\hid_api.o --depend=.\obj\hid_api.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\ -I..\..\..\..\CMSIS\CM0\CoreSupport -I..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx -I..\..\..\Include -I..\..\..\Include\Driver -I..\..\..\Include\NUC1xx-LB_002 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\hid_api.crf HID_API.c]
                          THUMB

                          AREA ||i.DrvUSB_BusResumeCallback||, CODE, READONLY, ALIGN=1

                  DrvUSB_BusResumeCallback PROC
;;;889    
;;;890    void DrvUSB_BusResumeCallback(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;891    {
000002  4605              MOV      r5,r0
;;;892    	DrvUSB_SetUsbState((E_DRVUSB_STATE)((uint32_t)DrvUSB_GetUsbState() & (uint32_t)(~eDRVUSB_SUSPENDED)));
000004  f7fffffe          BL       DrvUSB_GetUsbState
000008  2120              MOVS     r1,#0x20
00000a  4388              BICS     r0,r0,r1
00000c  4604              MOV      r4,r0
00000e  f7fffffe          BL       DrvUSB_SetUsbState
;;;893    }
000012  bd70              POP      {r4-r6,pc}
;;;894    
                          ENDP


                          AREA ||i.DrvUSB_BusSuspendCallback||, CODE, READONLY, ALIGN=1

                  DrvUSB_BusSuspendCallback PROC
;;;883    
;;;884    void DrvUSB_BusSuspendCallback(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;885    {
000002  4605              MOV      r5,r0
;;;886    	/* Note!! We should not power down or idle in Handler mode */
;;;887    	DrvUSB_SetUsbState((E_DRVUSB_STATE)((uint32_t)DrvUSB_GetUsbState() | (uint32_t)eDRVUSB_SUSPENDED));
000004  f7fffffe          BL       DrvUSB_GetUsbState
000008  2120              MOVS     r1,#0x20
00000a  4308              ORRS     r0,r0,r1
00000c  4604              MOV      r4,r0
00000e  f7fffffe          BL       DrvUSB_SetUsbState
;;;888    }
000012  bd70              POP      {r4-r6,pc}
;;;889    
                          ENDP


                          AREA ||i.HID_GetOutReportAck||, CODE, READONLY, ALIGN=1

                  HID_GetOutReportAck PROC
;;;740    Therefore, we could prepare next out report here. */
;;;741    void HID_GetOutReportAck(uint8_t *buf, uint32_t size)
000000  4770              BX       lr
;;;742    {
;;;743    
;;;744    }
;;;745    
                          ENDP


                          AREA ||i.HID_Init||, CODE, READONLY, ALIGN=2

                  HID_Init PROC
;;;462    
;;;463    void HID_Init(void)
000000  b510              PUSH     {r4,lr}
;;;464    {
;;;465    	/* Open HID to initial the descriptors and control handlers */
;;;466    	HID_Open();
000002  f7fffffe          BL       HID_Open
;;;467    
;;;468    #if(HID_FUNCTION == HID_MOUSE)
;;;469    
;;;470    	/* Set the HID report descriptor */
;;;471    	HID_SetReportDescriptor(g_HID_au8MouseReportDescriptor, g_HID_u32MouseReportDescriptorSize);
000006  2132              MOVS     r1,#0x32
000008  4803              LDR      r0,|L4.24|
00000a  f7fffffe          BL       HID_SetReportDescriptor
;;;472    
;;;473    	/* Set the HID report buffer */
;;;474    	HID_SetReportBuf(g_au8MouseReport, g_u32MouseReportSize);
00000e  2103              MOVS     r1,#3
000010  4802              LDR      r0,|L4.28|
000012  f7fffffe          BL       HID_SetReportBuf
;;;475    
;;;476    #elif(HID_FUNCTION == HID_DIGITIZER)
;;;477    	/* Set the HID report descriptor */
;;;478    	HID_SetReportDescriptor(g_HID_au8DigitizerReportDescriptor, g_HID_u32DigitizerReportDescriptorSize);
;;;479    
;;;480    	/* Set the HID report buffer */
;;;481    	HID_SetReportBuf(g_au8DigitizerReport, g_u32DigitizerReportSize);
;;;482    #else
;;;483    	/* Set the HID report descriptor */
;;;484    	HID_SetReportDescriptor(g_HID_au8KeyboardReportDescriptor, g_HID_u32KeyboardReportDescriptorSize);
;;;485    
;;;486    	/* Set the HID report buffer */
;;;487    	HID_SetReportBuf(g_au8KeyboardReport, g_u32KeyboardReportSize);
;;;488    #endif
;;;489    
;;;490    }
000016  bd10              POP      {r4,pc}
;;;491    
                          ENDP

                  |L4.24|
                          DCD      g_HID_au8MouseReportDescriptor
                  |L4.28|
                          DCD      g_au8MouseReport

                          AREA ||i.HID_MainProcess||, CODE, READONLY, ALIGN=2

                  HID_MainProcess PROC
;;;817    
;;;818    int32_t HID_MainProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;819    {
;;;820    
;;;821    	int32_t i32Ret = 0;
000002  2500              MOVS     r5,#0
;;;822    	E_DRVUSB_STATE eUsbState;
;;;823    
;;;824    	//GPIOD->IEN = (1 << 1);
;;;825    	NVIC_EnableIRQ(GPCDE_IRQn);
000004  bf00              NOP      
000006  2005              MOVS     r0,#5
000008  2101              MOVS     r1,#1
00000a  4081              LSLS     r1,r1,r0
00000c  4819              LDR      r0,|L5.116|
00000e  6001              STR      r1,[r0,#0]
000010  bf00              NOP      
;;;826    
;;;827    	i32Ret = DrvUSB_Open((void *)DrvUSB_DispatchEvent);
000012  4819              LDR      r0,|L5.120|
000014  f7fffffe          BL       DrvUSB_Open
000018  4605              MOV      r5,r0
;;;828    	if(i32Ret != 0)
00001a  2d00              CMP      r5,#0
00001c  d001              BEQ      |L5.34|
;;;829    		return i32Ret;
00001e  4628              MOV      r0,r5
;;;830    
;;;831    	DrvUART_EnableInt(UART_PORT0, DRVUART_RDAINT, UART_INT_HANDLE);  
;;;832    
;;;833    
;;;834    
;;;835    	while(1)
;;;836    	{
;;;837    		/* Disable USB-related interrupts. */
;;;838    		_DRVUSB_ENABLE_MISC_INT(0);
;;;839    
;;;840    		/* Enable float-detection interrupt. */
;;;841    		_DRVUSB_ENABLE_FLDET_INT();
;;;842    
;;;843    		/* Start HID and install the callback functions to handle in/out report */
;;;844    		HID_Init();
;;;845    
;;;846    		/* Enable USB-related interrupts. */
;;;847    		_DRVUSB_ENABLE_MISC_INT(INTEN_WAKEUP | INTEN_WAKEUPEN | INTEN_FLDET | INTEN_USB | INTEN_BUS);
;;;848    
;;;849    		/* Enter power down to wait USB attached */
;;;850    		// PowerDown();
;;;851    
;;;852    		/* Poll and handle USB events. */
;;;853    		while(1)
;;;854    		{	
;;;855    
;;;856    			// show_string(0,10,"dx");
;;;857    			eUsbState = DrvUSB_GetUsbState();
;;;858    
;;;859    			if (eUsbState == eDRVUSB_DETACHED)
;;;860    			{	 
;;;861    				DBG_PRINTF("USB Detached!\n");
;;;862    				break;
;;;863    			}
;;;864    
;;;865    			if (eUsbState & eDRVUSB_SUSPENDED)
;;;866    			{	
;;;867    				/* Enter suspend here */
;;;868    				// PowerDown();
;;;869    			}
;;;870    
;;;871    			if (eUsbState == eDRVUSB_CONFIGURED)
;;;872    			{	 
;;;873    				/* Set HID IN report for interrupt IN transfer */
;;;874    
;;;875    				HID_SetInReport();
;;;876    			}
;;;877    		}
;;;878    
;;;879    		/* Disable USB-related interrupts. */
;;;880    		_DRVUSB_ENABLE_MISC_INT(0);
;;;881    	}
;;;882    }
000020  bd70              POP      {r4-r6,pc}
                  |L5.34|
000022  4a16              LDR      r2,|L5.124|
000024  2101              MOVS     r1,#1                 ;831
000026  2000              MOVS     r0,#0                 ;831
000028  f7fffffe          BL       DrvUART_EnableInt
00002c  e021              B        |L5.114|
                  |L5.46|
00002e  2000              MOVS     r0,#0                 ;838
000030  4913              LDR      r1,|L5.128|
000032  6008              STR      r0,[r1,#0]            ;838
000034  4608              MOV      r0,r1                 ;841
000036  6800              LDR      r0,[r0,#0]            ;841
000038  2104              MOVS     r1,#4                 ;841
00003a  4388              BICS     r0,r0,r1              ;841
00003c  1d00              ADDS     r0,r0,#4              ;841
00003e  4910              LDR      r1,|L5.128|
000040  6008              STR      r0,[r1,#0]            ;841
000042  f7fffffe          BL       HID_Init
000046  200f              MOVS     r0,#0xf               ;847
000048  490d              LDR      r1,|L5.128|
00004a  6008              STR      r0,[r1,#0]            ;847
00004c  e00c              B        |L5.104|
                  |L5.78|
00004e  f7fffffe          BL       DrvUSB_GetUsbState
000052  4604              MOV      r4,r0                 ;857
000054  2c00              CMP      r4,#0                 ;859
000056  d103              BNE      |L5.96|
000058  a00a              ADR      r0,|L5.132|
00005a  f7fffffe          BL       __2printf
00005e  e004              B        |L5.106|
                  |L5.96|
000060  2c1f              CMP      r4,#0x1f              ;871
000062  d101              BNE      |L5.104|
000064  f7fffffe          BL       HID_SetInReport
                  |L5.104|
000068  e7f1              B        |L5.78|
                  |L5.106|
00006a  bf00              NOP                            ;862
00006c  2000              MOVS     r0,#0                 ;880
00006e  4904              LDR      r1,|L5.128|
000070  6008              STR      r0,[r1,#0]            ;880
                  |L5.114|
000072  e7dc              B        |L5.46|
;;;883    
                          ENDP

                  |L5.116|
                          DCD      0xe000e100
                  |L5.120|
                          DCD      DrvUSB_DispatchEvent
                  |L5.124|
                          DCD      UART_INT_HANDLE
                  |L5.128|
                          DCD      0x40060000
                  |L5.132|
000084  55534220          DCB      "USB Detached!\n",0
000088  44657461
00008c  63686564
000090  210a00  
000093  00                DCB      0

                          AREA ||i.HID_SetFirstInReport||, CODE, READONLY, ALIGN=2

                  HID_SetFirstInReport PROC
;;;732    /* This function is used to prepare the first in report */
;;;733    void HID_SetFirstInReport(void)
000000  b510              PUSH     {r4,lr}
;;;734    {
;;;735    	DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);
000002  4803              LDR      r0,|L6.16|
000004  6a82              LDR      r2,[r0,#0x28]  ; g_HID_sDevice
000006  6a41              LDR      r1,[r0,#0x24]  ; g_HID_sDevice
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       DrvUSB_DataIn
;;;736    }
00000e  bd10              POP      {r4,pc}
;;;737    
                          ENDP

                  |L6.16|
                          DCD      g_HID_sDevice

                          AREA ||i.HID_SetFirstOutReport||, CODE, READONLY, ALIGN=1

                  HID_SetFirstOutReport PROC
;;;726    /* This function is used to prepare the first out report. */
;;;727    void HID_SetFirstOutReport(void)
000000  4770              BX       lr
;;;728    {
;;;729    
;;;730    }
;;;731    
                          ENDP


                          AREA ||i.HID_SetInReport||, CODE, READONLY, ALIGN=2

                  HID_SetInReport PROC
;;;494    /* This function is used to prepare IN report. The g_HID_sDevice.u32ReportSize will be reset when it has been done. */
;;;495    void HID_SetInReport()
000000  b570              PUSH     {r4-r6,lr}
;;;496    {	char x='a';
000002  2561              MOVS     r5,#0x61
;;;497    	uint8_t *buf;
;;;498    	/* To check if previous report data is processed or not */
;;;499    	if(g_HID_sDevice.isReportReady)
000004  4810              LDR      r0,|L8.72|
000006  7b00              LDRB     r0,[r0,#0xc]
000008  2800              CMP      r0,#0
00000a  d000              BEQ      |L8.14|
                  |L8.12|
;;;500    		return;
;;;501    
;;;502    	buf = g_HID_sDevice.pu8Report;
;;;503    
;;;504    	/* Move mouse when GPD1 == 0 */
;;;505    //	if ((GPIOD->PIN & (1 << 1)) == 0)
;;;506    	{
;;;507    	/*	if(comRbuf[0]=='1') 
;;;508    		{
;;;509    			buf[0] = 0x00; 	
;;;510    			buf[1] = 1; 	
;;;511    			buf[2] = 0x00; 	
;;;512    		}
;;;513    		else if(comRbuf[0]=='2') 
;;;514    		{
;;;515    			buf[0] = 0x00; 	
;;;516    			buf[1] = 0x00; 	
;;;517    			buf[2] = 0x01; 	
;;;518    		}
;;;519    		else if(comRbuf[0]=='3') 
;;;520    		{
;;;521    			//buf[0] = 0x06; 
;;;522    		}
;;;523    		else
;;;524    		{
;;;525    			buf[0] = 0x00; 	
;;;526    			buf[1] = 0x00; 	
;;;527    			buf[2] = 0x00; 	
;;;528    		}					*/
;;;529    		//buf[0] = comRbuf3; 	
;;;530    		buf[0] = 0x00; 
;;;531    		buf[1] = -comRbuf*2; 
;;;532    		buf[2] = -comRbuf2*2; 
;;;533    	
;;;534    		g_HID_sDevice.isReportReady = 1; /* To note the report data has been updated */
;;;535    		DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);	
;;;536    	}
;;;537    }
00000c  bd70              POP      {r4-r6,pc}
                  |L8.14|
00000e  480e              LDR      r0,|L8.72|
000010  3820              SUBS     r0,r0,#0x20           ;502
000012  6a44              LDR      r4,[r0,#0x24]         ;502  ; g_HID_sDevice
000014  2000              MOVS     r0,#0                 ;530
000016  7020              STRB     r0,[r4,#0]            ;530
000018  480c              LDR      r0,|L8.76|
00001a  6800              LDR      r0,[r0,#0]            ;531  ; comRbuf
00001c  4240              RSBS     r0,r0,#0              ;531
00001e  0640              LSLS     r0,r0,#25             ;531
000020  0e00              LSRS     r0,r0,#24             ;531
000022  7060              STRB     r0,[r4,#1]            ;531
000024  480a              LDR      r0,|L8.80|
000026  6800              LDR      r0,[r0,#0]            ;532  ; comRbuf2
000028  4240              RSBS     r0,r0,#0              ;532
00002a  0640              LSLS     r0,r0,#25             ;532
00002c  0e00              LSRS     r0,r0,#24             ;532
00002e  70a0              STRB     r0,[r4,#2]            ;532
000030  2101              MOVS     r1,#1                 ;534
000032  4805              LDR      r0,|L8.72|
000034  7301              STRB     r1,[r0,#0xc]          ;534
000036  3820              SUBS     r0,r0,#0x20           ;535
000038  6a82              LDR      r2,[r0,#0x28]         ;535  ; g_HID_sDevice
00003a  6a41              LDR      r1,[r0,#0x24]         ;535  ; g_HID_sDevice
00003c  2001              MOVS     r0,#1                 ;535
00003e  f7fffffe          BL       DrvUSB_DataIn
000042  bf00              NOP      
000044  e7e2              B        |L8.12|
;;;538    
                          ENDP

000046  0000              DCW      0x0000
                  |L8.72|
                          DCD      g_HID_sDevice+0x20
                  |L8.76|
                          DCD      comRbuf
                  |L8.80|
                          DCD      comRbuf2

                          AREA ||i.PowerDown||, CODE, READONLY, ALIGN=2

                  PowerDown PROC
;;;745    
;;;746    void PowerDown()
000000  b510              PUSH     {r4,lr}
;;;747    {
;;;748    	DBG_PRINTF("Enter power down ...\n");
000002  a02a              ADR      r0,|L9.172|
000004  f7fffffe          BL       __2printf
;;;749    
;;;750    	UNLOCKREG();
000008  2059              MOVS     r0,#0x59
00000a  492e              LDR      r1,|L9.196|
00000c  6008              STR      r0,[r1,#0]
00000e  2016              MOVS     r0,#0x16
000010  6008              STR      r0,[r1,#0]
000012  2088              MOVS     r0,#0x88
000014  6008              STR      r0,[r1,#0]
;;;751    
;;;752    	while ( IsDebugFifoEmpty() == FALSE );
000016  bf00              NOP      
                  |L9.24|
000018  f7fffffe          BL       IsDebugFifoEmpty
00001c  2800              CMP      r0,#0
00001e  d0fb              BEQ      |L9.24|
;;;753    
;;;754    	/* Wakeup Enable */
;;;755    	USBD->INTEN.WAKEUP_EN = 1;
000020  4829              LDR      r0,|L9.200|
000022  6800              LDR      r0,[r0,#0]
000024  21ff              MOVS     r1,#0xff
000026  3101              ADDS     r1,#1
000028  4388              BICS     r0,r0,r1
00002a  1840              ADDS     r0,r0,r1
00002c  4926              LDR      r1,|L9.200|
00002e  6008              STR      r0,[r1,#0]
;;;756    
;;;757    	/* Deep sleep */
;;;758    	outp32(0xE000ED10, 4);
000030  2004              MOVS     r0,#4
000032  4926              LDR      r1,|L9.204|
000034  6108              STR      r0,[r1,#0x10]
;;;759    	SYSCLK->PWRCON.PD_WAIT_CPU = 1;
000036  4826              LDR      r0,|L9.208|
000038  6800              LDR      r0,[r0,#0]
00003a  21ff              MOVS     r1,#0xff
00003c  3101              ADDS     r1,#1
00003e  4388              BICS     r0,r0,r1
000040  1840              ADDS     r0,r0,r1
000042  4923              LDR      r1,|L9.208|
000044  6008              STR      r0,[r1,#0]
;;;760    	SYSCLK->PWRCON.PWR_DOWN_EN = 1;
000046  4608              MOV      r0,r1
000048  6800              LDR      r0,[r0,#0]
00004a  2180              MOVS     r1,#0x80
00004c  4388              BICS     r0,r0,r1
00004e  3080              ADDS     r0,r0,#0x80
000050  491f              LDR      r1,|L9.208|
000052  6008              STR      r0,[r1,#0]
;;;761    	__WFI();
000054  bf30              WFI      
;;;762    	SYSCLK->PWRCON.PWR_DOWN_EN = 0;
000056  4608              MOV      r0,r1
000058  6800              LDR      r0,[r0,#0]
00005a  2180              MOVS     r1,#0x80
00005c  4388              BICS     r0,r0,r1
00005e  491c              LDR      r1,|L9.208|
000060  6008              STR      r0,[r1,#0]
;;;763    
;;;764    	if(DrvUSB_GetUsbState() & eDRVUSB_SUSPENDED)
000062  f7fffffe          BL       DrvUSB_GetUsbState
000066  2120              MOVS     r1,#0x20
000068  4208              TST      r0,r1
00006a  d01b              BEQ      |L9.164|
;;;765    	{
;;;766    		/* Note HOST to resume USB tree if it is suspended and remote wakeup enabled */
;;;767    		if(DrvUSB_IsRemoteWakeupEnabled())
00006c  f7fffffe          BL       DrvUSB_IsRemoteWakeupEnabled
000070  2800              CMP      r0,#0
000072  d017              BEQ      |L9.164|
;;;768    		{
;;;769    			/* Enable PHY before sending Resume('K') state */
;;;770    			USBD->ATTR.PHY_EN = 1;
000074  4814              LDR      r0,|L9.200|
000076  6900              LDR      r0,[r0,#0x10]
000078  2110              MOVS     r1,#0x10
00007a  4388              BICS     r0,r0,r1
00007c  3010              ADDS     r0,r0,#0x10
00007e  4912              LDR      r1,|L9.200|
000080  6108              STR      r0,[r1,#0x10]
;;;771    
;;;772    			/* Keep remote wakeup for 1 ms */
;;;773    			USBD->ATTR.RWAKEUP = 1;
000082  4608              MOV      r0,r1
000084  6900              LDR      r0,[r0,#0x10]
000086  2120              MOVS     r1,#0x20
000088  4388              BICS     r0,r0,r1
00008a  3020              ADDS     r0,r0,#0x20
00008c  490e              LDR      r1,|L9.200|
00008e  6108              STR      r0,[r1,#0x10]
;;;774    			DrvSYS_Delay(1000); /* Delay 1ms */
000090  207d              MOVS     r0,#0x7d
000092  00c0              LSLS     r0,r0,#3
000094  f7fffffe          BL       DrvSYS_Delay
;;;775    			USBD->ATTR.RWAKEUP = 0;
000098  480b              LDR      r0,|L9.200|
00009a  6900              LDR      r0,[r0,#0x10]
00009c  2120              MOVS     r1,#0x20
00009e  4388              BICS     r0,r0,r1
0000a0  4909              LDR      r1,|L9.200|
0000a2  6108              STR      r0,[r1,#0x10]
                  |L9.164|
;;;776    		}
;;;777    	}
;;;778    
;;;779    	DBG_PRINTF("device wakeup!\n");
0000a4  a00b              ADR      r0,|L9.212|
0000a6  f7fffffe          BL       __2printf
;;;780    
;;;781    }
0000aa  bd10              POP      {r4,pc}
;;;782    
                          ENDP

                  |L9.172|
0000ac  456e7465          DCB      "Enter power down ...\n",0
0000b0  7220706f
0000b4  77657220
0000b8  646f776e
0000bc  202e2e2e
0000c0  0a00    
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L9.196|
                          DCD      0x50000100
                  |L9.200|
                          DCD      0x40060000
                  |L9.204|
                          DCD      0xe000ed00
                  |L9.208|
                          DCD      0x50000200
                  |L9.212|
0000d4  64657669          DCB      "device wakeup!\n",0
0000d8  63652077
0000dc  616b6575
0000e0  70210a00

                          AREA ||i.UART_INT_HANDLE||, CODE, READONLY, ALIGN=2

                  UART_INT_HANDLE PROC
;;;783    
;;;784    void UART_INT_HANDLE(void)
000000  b538              PUSH     {r3-r5,lr}
;;;785    {
;;;786    	uint8_t bInChar[1] = {0xFF};
000002  a02c              ADR      r0,|L10.180|
000004  6800              LDR      r0,[r0,#0]
000006  9000              STR      r0,[sp,#0]
;;;787    	int i=0;
000008  2400              MOVS     r4,#0
;;;788    	while(UART0->ISR.RDA_IF==1) 
00000a  e04c              B        |L10.166|
                  |L10.12|
;;;789    	{
;;;790    		DrvUART_Read(UART_PORT0,bInChar,1);	
00000c  2201              MOVS     r2,#1
00000e  4669              MOV      r1,sp
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       DrvUART_Read
;;;791    		if(bInChar[0]=='s') // check if Buffer is full
000016  4668              MOV      r0,sp
000018  7800              LDRB     r0,[r0,#0]
00001a  2873              CMP      r0,#0x73
00001c  d143              BNE      |L10.166|
;;;792    		{
;;;793    		    DrvUART_Read(UART_PORT0,bInChar,1);	
00001e  2201              MOVS     r2,#1
000020  4669              MOV      r1,sp
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       DrvUART_Read
;;;794    			if(bInChar[0]=='n')
000028  4668              MOV      r0,sp
00002a  7800              LDRB     r0,[r0,#0]
00002c  286e              CMP      r0,#0x6e
00002e  d10e              BNE      |L10.78|
;;;795    			{
;;;796    				DrvUART_Read(UART_PORT0,bInChar,1);	
000030  2201              MOVS     r2,#1
000032  4669              MOV      r1,sp
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       DrvUART_Read
;;;797    				comRbuf = bInChar[0]-'0';
00003a  4668              MOV      r0,sp
00003c  7800              LDRB     r0,[r0,#0]
00003e  3830              SUBS     r0,r0,#0x30
000040  491d              LDR      r1,|L10.184|
000042  6008              STR      r0,[r1,#0]  ; comRbuf
;;;798    				comRbuf =0-comRbuf; 
000044  4608              MOV      r0,r1
000046  6800              LDR      r0,[r0,#0]  ; comRbuf
000048  4240              RSBS     r0,r0,#0
00004a  6008              STR      r0,[r1,#0]  ; comRbuf
00004c  e004              B        |L10.88|
                  |L10.78|
;;;799    			}
;;;800    			else
;;;801    				comRbuf = bInChar[0]-'0';
00004e  4668              MOV      r0,sp
000050  7800              LDRB     r0,[r0,#0]
000052  3830              SUBS     r0,r0,#0x30
000054  4918              LDR      r1,|L10.184|
000056  6008              STR      r0,[r1,#0]  ; comRbuf
                  |L10.88|
;;;802    		 	DrvUART_Read(UART_PORT0,bInChar,1);	
000058  2201              MOVS     r2,#1
00005a  4669              MOV      r1,sp
00005c  2000              MOVS     r0,#0
00005e  f7fffffe          BL       DrvUART_Read
;;;803    			if(bInChar[0]=='n')
000062  4668              MOV      r0,sp
000064  7800              LDRB     r0,[r0,#0]
000066  286e              CMP      r0,#0x6e
000068  d10e              BNE      |L10.136|
;;;804    			{
;;;805    				DrvUART_Read(UART_PORT0,bInChar,1);	
00006a  2201              MOVS     r2,#1
00006c  4669              MOV      r1,sp
00006e  2000              MOVS     r0,#0
000070  f7fffffe          BL       DrvUART_Read
;;;806    				comRbuf2 = bInChar[0]-'0';
000074  4668              MOV      r0,sp
000076  7800              LDRB     r0,[r0,#0]
000078  3830              SUBS     r0,r0,#0x30
00007a  4910              LDR      r1,|L10.188|
00007c  6008              STR      r0,[r1,#0]  ; comRbuf2
;;;807    				comRbuf2 =0-comRbuf2; 
00007e  4608              MOV      r0,r1
000080  6800              LDR      r0,[r0,#0]  ; comRbuf2
000082  4240              RSBS     r0,r0,#0
000084  6008              STR      r0,[r1,#0]  ; comRbuf2
000086  e004              B        |L10.146|
                  |L10.136|
;;;808    			}
;;;809    			else
;;;810    				comRbuf2 = bInChar[0]-'0';
000088  4668              MOV      r0,sp
00008a  7800              LDRB     r0,[r0,#0]
00008c  3830              SUBS     r0,r0,#0x30
00008e  490b              LDR      r1,|L10.188|
000090  6008              STR      r0,[r1,#0]  ; comRbuf2
                  |L10.146|
;;;811    			DrvUART_Read(UART_PORT0,bInChar,1);	
000092  2201              MOVS     r2,#1
000094  4669              MOV      r1,sp
000096  2000              MOVS     r0,#0
000098  f7fffffe          BL       DrvUART_Read
;;;812    			comRbuf3 = bInChar[0]-'0';
00009c  4668              MOV      r0,sp
00009e  7800              LDRB     r0,[r0,#0]
0000a0  3830              SUBS     r0,r0,#0x30
0000a2  4907              LDR      r1,|L10.192|
0000a4  6008              STR      r0,[r1,#0]  ; comRbuf3
                  |L10.166|
0000a6  4807              LDR      r0,|L10.196|
0000a8  69c0              LDR      r0,[r0,#0x1c]         ;788
0000aa  07c0              LSLS     r0,r0,#31             ;788
0000ac  0fc0              LSRS     r0,r0,#31             ;788
0000ae  2801              CMP      r0,#1                 ;788
0000b0  d0ac              BEQ      |L10.12|
;;;813    		}
;;;814    	}
;;;815    }
0000b2  bd38              POP      {r3-r5,pc}
;;;816    
                          ENDP

                  |L10.180|
0000b4  ff00              DCB      255,0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L10.184|
                          DCD      comRbuf
                  |L10.188|
                          DCD      comRbuf2
                  |L10.192|
                          DCD      comRbuf3
                  |L10.196|
                          DCD      0x40050000

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_sVendorStringDesc
000000  1003              DCB      0x10,0x03
000002  004e              DCW      0x004e
000004  00550056          DCW      0x0055,0x0056
000008  004f0054          DCW      0x004f,0x0054
00000c  004f004e          DCW      0x004f,0x004e
                          %        184
0000c8  0000              DCB      0x00,0x00
                  g_sProductStringDesc
0000ca  1603              DCB      0x16,0x03
0000cc  00410052          DCW      0x0041,0x0052
0000d0  004d0020          DCW      0x004d,0x0020
0000d4  00730065          DCW      0x0073,0x0065
0000d8  00720069          DCW      0x0072,0x0069
0000dc  00650073          DCW      0x0065,0x0073
                          %        180
                  g_HID_au8MouseReportDescriptor
000194  05010902          DCB      0x05,0x01,0x09,0x02
000198  a1010901          DCB      0xa1,0x01,0x09,0x01
00019c  a1000509          DCB      0xa1,0x00,0x05,0x09
0001a0  19012903          DCB      0x19,0x01,0x29,0x03
0001a4  15002501          DCB      0x15,0x00,0x25,0x01
0001a8  95037501          DCB      0x95,0x03,0x75,0x01
0001ac  81029501          DCB      0x81,0x02,0x95,0x01
0001b0  75058101          DCB      0x75,0x05,0x81,0x01
0001b4  05010930          DCB      0x05,0x01,0x09,0x30
0001b8  09311581          DCB      0x09,0x31,0x15,0x81
0001bc  257f7508          DCB      0x25,0x7f,0x75,0x08
0001c0  95028106          DCB      0x95,0x02,0x81,0x06
0001c4  c0c00000          DCB      0xc0,0xc0,0x00,0x00
                  g_HID_u32MouseReportDescriptorSize
                          DCD      0x00000032
                  g_u32MouseReportSize
                          DCD      0x00000003
                  g_HID_au8DeviceDescriptor
0001d0  12010002          DCB      0x12,0x01,0x00,0x02
0001d4  00000008          DCB      0x00,0x00,0x00,0x08
0001d8  160442c1          DCB      0x16,0x04,0x42,0xc1
0001dc  00000102          DCB      0x00,0x00,0x01,0x02
0001e0  0001              DCB      0x00,0x01
                  g_HID_au8ConfigDescriptor
0001e2  0902              DCB      0x09,0x02
0001e4  22000101          DCB      0x22,0x00,0x01,0x01
0001e8  00a03209          DCB      0x00,0xa0,0x32,0x09
0001ec  04000001          DCB      0x04,0x00,0x00,0x01
0001f0  03010200          DCB      0x03,0x01,0x02,0x00
0001f4  09211001          DCB      0x09,0x21,0x10,0x01
0001f8  00012232          DCB      0x00,0x01,0x22,0x32
0001fc  00070581          DCB      0x00,0x07,0x05,0x81
000200  03400014          DCB      0x03,0x40,0x00,0x14
                  g_HID_au8StringLang
000204  04030904          DCB      0x04,0x03,0x09,0x04
                  g_HID_sVendorStringDesc
000208  1003              DCB      0x10,0x03
00020a  004e              DCW      0x004e
00020c  00550056          DCW      0x0055,0x0056
000210  004f0054          DCW      0x004f,0x0054
000214  004f004e          DCW      0x004f,0x004e
                          %        184
0002d0  0000              DCB      0x00,0x00
                  g_HID_sProductStringDesc
0002d2  1003              DCB      0x10,0x03
0002d4  00570050          DCW      0x0057,0x0050
0002d8  004d0020          DCW      0x004d,0x0020
0002dc  00550053          DCW      0x0055,0x0053
0002e0  0042              DCW      0x0042
0002e2  0000              DCB      0x00,0x00
                          %        184
                  g_HID_au8StringSerial
00039c  1a034200          DCB      0x1a,0x03,0x42,0x00
0003a0  30003200          DCB      0x30,0x00,0x32,0x00
0003a4  30003000          DCB      0x30,0x00,0x30,0x00
0003a8  36003000          DCB      0x36,0x00,0x30,0x00
0003ac  39003200          DCB      0x39,0x00,0x32,0x00
0003b0  31003100          DCB      0x31,0x00,0x31,0x00
0003b4  3400              DCB      0x34,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  TEXT1
000000  54583a20          DCB      0x54,0x58,0x3a,0x20
000004  73656e64          DCB      0x73,0x65,0x6e,0x64
000008  696e672e          DCB      0x69,0x6e,0x67,0x2e
00000c  2e2e2020          DCB      0x2e,0x2e,0x20,0x20
                  TEXT2
000010  52583a20          DCB      0x52,0x58,0x3a,0x20
000014  20202020          DCB      0x20,0x20,0x20,0x20
000018  20202000          DCB      0x20,0x20,0x20,0x00
                          DCD      0x00000000
                  comRbytes
000020  0000              DCW      0x0000
                  comRhead
000022  0000              DCW      0x0000
                  comRtail
000024  0000              DCW      0x0000
                  ADC_result
000026  0000              DCB      0x00,0x00
                  comRbuf
                          DCD      0x00000000
                  comRbuf2
                          DCD      0x00000000
                  comRbuf3
                          DCD      0x00000000
                  g_au8MouseReport
000034  000000            DCB      0x00,0x00,0x00
