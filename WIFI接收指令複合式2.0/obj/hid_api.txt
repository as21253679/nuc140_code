; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\hid_api.o --depend=.\obj\hid_api.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\ -I..\..\..\..\CMSIS\CM0\CoreSupport -I..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx -I..\..\..\Include -I..\..\..\Include\Driver -I..\..\..\Include\NUC1xx-LB_002 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\hid_api.crf HID_API.c]
                          THUMB

                          AREA ||i.DrvUSB_BusResumeCallback||, CODE, READONLY, ALIGN=1

                  DrvUSB_BusResumeCallback PROC
;;;630    
;;;631    void DrvUSB_BusResumeCallback(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;632    {
000002  4605              MOV      r5,r0
;;;633        DrvUSB_SetUsbState((E_DRVUSB_STATE)((uint32_t)DrvUSB_GetUsbState() & (uint32_t)(~eDRVUSB_SUSPENDED)));
000004  f7fffffe          BL       DrvUSB_GetUsbState
000008  2120              MOVS     r1,#0x20
00000a  4388              BICS     r0,r0,r1
00000c  4604              MOV      r4,r0
00000e  f7fffffe          BL       DrvUSB_SetUsbState
;;;634    }
000012  bd70              POP      {r4-r6,pc}
;;;635    
                          ENDP


                          AREA ||i.DrvUSB_BusSuspendCallback||, CODE, READONLY, ALIGN=1

                  DrvUSB_BusSuspendCallback PROC
;;;624    
;;;625    void DrvUSB_BusSuspendCallback(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;626    {
000002  4605              MOV      r5,r0
;;;627        /* Note!! We should not power down or idle in Handler mode */
;;;628        DrvUSB_SetUsbState((E_DRVUSB_STATE)((uint32_t)DrvUSB_GetUsbState() | (uint32_t)eDRVUSB_SUSPENDED));
000004  f7fffffe          BL       DrvUSB_GetUsbState
000008  2120              MOVS     r1,#0x20
00000a  4308              ORRS     r0,r0,r1
00000c  4604              MOV      r4,r0
00000e  f7fffffe          BL       DrvUSB_SetUsbState
;;;629    }
000012  bd70              POP      {r4-r6,pc}
;;;630    
                          ENDP


                          AREA ||i.HID_GetOutReportAck||, CODE, READONLY, ALIGN=1

                  HID_GetOutReportAck PROC
;;;468       Therefore, we could prepare next out report here. */
;;;469    void HID_GetOutReportAck(uint8_t *buf, uint32_t size)
000000  4770              BX       lr
;;;470    {
;;;471        
;;;472    }
;;;473    
                          ENDP


                          AREA ||i.HID_Init||, CODE, READONLY, ALIGN=2

                  HID_Init PROC
;;;349    
;;;350    void HID_Init(void)
000000  b510              PUSH     {r4,lr}
;;;351    {
;;;352        /* Open HID to initial the descriptors and control handlers */
;;;353        HID_Open();
000002  f7fffffe          BL       HID_Open
;;;354        
;;;355        /* Set the HID report descriptor */
;;;356        HID_SetReportDescriptor_MS(g_HID_au8MouseReportDescriptor, g_HID_u32MouseReportDescriptorSize);
000006  2132              MOVS     r1,#0x32
000008  4807              LDR      r0,|L4.40|
00000a  f7fffffe          BL       HID_SetReportDescriptor_MS
;;;357    
;;;358        /* Set the HID report buffer */
;;;359        HID_SetReportBuf_MS(g_au8MouseReport, g_u32MouseReportSize);
00000e  2103              MOVS     r1,#3
000010  4806              LDR      r0,|L4.44|
000012  f7fffffe          BL       HID_SetReportBuf_MS
;;;360    
;;;361        /* Set the HID report descriptor */
;;;362        HID_SetReportDescriptor_KB(g_HID_au8KeyboardReportDescriptor, g_HID_u32KeyboardReportDescriptorSize);
000016  216e              MOVS     r1,#0x6e
000018  4805              LDR      r0,|L4.48|
00001a  f7fffffe          BL       HID_SetReportDescriptor_KB
;;;363    
;;;364        /* Set the HID report buffer */
;;;365        HID_SetReportBuf_KB(g_au8KeyboardReport, g_u32KeyboardReportSize);
00001e  2109              MOVS     r1,#9
000020  4804              LDR      r0,|L4.52|
000022  f7fffffe          BL       HID_SetReportBuf_KB
;;;366    
;;;367    }
000026  bd10              POP      {r4,pc}
;;;368    
                          ENDP

                  |L4.40|
                          DCD      g_HID_au8MouseReportDescriptor
                  |L4.44|
                          DCD      g_au8MouseReport
                  |L4.48|
                          DCD      g_HID_au8KeyboardReportDescriptor
                  |L4.52|
                          DCD      g_au8KeyboardReport

                          AREA ||i.HID_MainProcess||, CODE, READONLY, ALIGN=2

                  HID_MainProcess PROC
;;;559    
;;;560    int32_t HID_MainProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;561    {
;;;562        int32_t i32Ret = 0;
000002  2500              MOVS     r5,#0
;;;563        E_DRVUSB_STATE eUsbState;
;;;564    
;;;565        DBG_PRINTF("Use GPD1 to move mouse pointer right when GPD1 = 0\n");
000004  a024              ADR      r0,|L5.152|
000006  f7fffffe          BL       __2printf
;;;566        DBG_PRINTF("Use GPD2 to report a key 'a' when GPD2 = 0\n");
00000a  a030              ADR      r0,|L5.204|
00000c  f7fffffe          BL       __2printf
;;;567        
;;;568        GPIOD->IEN = (3 << 1);
000010  2006              MOVS     r0,#6
000012  4939              LDR      r1,|L5.248|
000014  61c8              STR      r0,[r1,#0x1c]
;;;569        NVIC_EnableIRQ(GPCDE_IRQn);
000016  bf00              NOP      
000018  2005              MOVS     r0,#5
00001a  2101              MOVS     r1,#1
00001c  4081              LSLS     r1,r1,r0
00001e  4837              LDR      r0,|L5.252|
000020  6001              STR      r1,[r0,#0]
000022  bf00              NOP      
;;;570        
;;;571        i32Ret = DrvUSB_Open((void *)DrvUSB_DispatchEvent);
000024  4836              LDR      r0,|L5.256|
000026  f7fffffe          BL       DrvUSB_Open
00002a  4605              MOV      r5,r0
;;;572        if(i32Ret != 0)
00002c  2d00              CMP      r5,#0
00002e  d001              BEQ      |L5.52|
;;;573            return i32Ret;
000030  4628              MOV      r0,r5
;;;574    	DrvUART_EnableInt(UART_PORT0, DRVUART_RDAINT, UART_INT_HANDLE);  
;;;575    
;;;576        
;;;577        while(1)
;;;578        {
;;;579            /* Disable USB-related interrupts. */
;;;580            _DRVUSB_ENABLE_MISC_INT(0);
;;;581    
;;;582            /* Enable float-detection interrupt. */
;;;583            _DRVUSB_ENABLE_FLDET_INT();
;;;584        
;;;585            /* Start HID and install the callback functions to handle in/out report */
;;;586            HID_Init();
;;;587    
;;;588            /* Enable USB-related interrupts. */
;;;589            _DRVUSB_ENABLE_MISC_INT(INTEN_WAKEUP | INTEN_WAKEUPEN | INTEN_FLDET | INTEN_USB | INTEN_BUS);
;;;590    
;;;591            /* Enter power down to wait USB attached */
;;;592          	 PowerDown();
;;;593    
;;;594            /* Poll and handle USB events. */
;;;595            while(1)
;;;596            {
;;;597                eUsbState = DrvUSB_GetUsbState();
;;;598    
;;;599                if (eUsbState == eDRVUSB_DETACHED)
;;;600                {
;;;601                    DBG_PRINTF("USB Detached!\n");
;;;602                    break;
;;;603                }
;;;604                
;;;605                if (eUsbState & eDRVUSB_SUSPENDED)
;;;606                {
;;;607                    /* Enter suspend here */
;;;608                   PowerDown();
;;;609                }
;;;610                
;;;611                if (eUsbState == eDRVUSB_CONFIGURED)
;;;612                {
;;;613                    /* Set HID IN report for interrupt IN transfer */
;;;614                    HID_SetInReport_MS();
;;;615    				HID_SetInReport_KB();
;;;616                }
;;;617            }
;;;618    
;;;619            /* Disable USB-related interrupts. */
;;;620            _DRVUSB_ENABLE_MISC_INT(0);
;;;621        }
;;;622    }
000032  bd70              POP      {r4-r6,pc}
                  |L5.52|
000034  4a33              LDR      r2,|L5.260|
000036  2101              MOVS     r1,#1                 ;574
000038  2000              MOVS     r0,#0                 ;574
00003a  f7fffffe          BL       DrvUART_EnableInt
00003e  e02a              B        |L5.150|
                  |L5.64|
000040  2000              MOVS     r0,#0                 ;580
000042  4931              LDR      r1,|L5.264|
000044  6008              STR      r0,[r1,#0]            ;580
000046  4608              MOV      r0,r1                 ;583
000048  6800              LDR      r0,[r0,#0]            ;583
00004a  2104              MOVS     r1,#4                 ;583
00004c  4388              BICS     r0,r0,r1              ;583
00004e  1d00              ADDS     r0,r0,#4              ;583
000050  492d              LDR      r1,|L5.264|
000052  6008              STR      r0,[r1,#0]            ;583
000054  f7fffffe          BL       HID_Init
000058  200f              MOVS     r0,#0xf               ;589
00005a  492b              LDR      r1,|L5.264|
00005c  6008              STR      r0,[r1,#0]            ;589
00005e  f7fffffe          BL       PowerDown
000062  e013              B        |L5.140|
                  |L5.100|
000064  f7fffffe          BL       DrvUSB_GetUsbState
000068  4604              MOV      r4,r0                 ;597
00006a  2c00              CMP      r4,#0                 ;599
00006c  d103              BNE      |L5.118|
00006e  a027              ADR      r0,|L5.268|
000070  f7fffffe          BL       __2printf
000074  e00b              B        |L5.142|
                  |L5.118|
000076  2020              MOVS     r0,#0x20              ;605
000078  4204              TST      r4,r0                 ;605
00007a  d001              BEQ      |L5.128|
00007c  f7fffffe          BL       PowerDown
                  |L5.128|
000080  2c1f              CMP      r4,#0x1f              ;611
000082  d103              BNE      |L5.140|
000084  f7fffffe          BL       HID_SetInReport_MS
000088  f7fffffe          BL       HID_SetInReport_KB
                  |L5.140|
00008c  e7ea              B        |L5.100|
                  |L5.142|
00008e  bf00              NOP                            ;602
000090  2000              MOVS     r0,#0                 ;620
000092  491d              LDR      r1,|L5.264|
000094  6008              STR      r0,[r1,#0]            ;620
                  |L5.150|
000096  e7d3              B        |L5.64|
;;;623    
                          ENDP

                  |L5.152|
000098  55736520          DCB      "Use GPD1 to move mouse pointer right when GPD1 = 0\n",0
00009c  47504431
0000a0  20746f20
0000a4  6d6f7665
0000a8  206d6f75
0000ac  73652070
0000b0  6f696e74
0000b4  65722072
0000b8  69676874
0000bc  20776865
0000c0  6e204750
0000c4  4431203d
0000c8  20300a00
                  |L5.204|
0000cc  55736520          DCB      "Use GPD2 to report a key 'a' when GPD2 = 0\n",0
0000d0  47504432
0000d4  20746f20
0000d8  7265706f
0000dc  72742061
0000e0  206b6579
0000e4  20276127
0000e8  20776865
0000ec  6e204750
0000f0  4432203d
0000f4  20300a00
                  |L5.248|
                          DCD      0x500040c0
                  |L5.252|
                          DCD      0xe000e100
                  |L5.256|
                          DCD      DrvUSB_DispatchEvent
                  |L5.260|
                          DCD      UART_INT_HANDLE
                  |L5.264|
                          DCD      0x40060000
                  |L5.268|
00010c  55534220          DCB      "USB Detached!\n",0
000110  44657461
000114  63686564
000118  210a00  
00011b  00                DCB      0

                          AREA ||i.HID_SetFirstInReport||, CODE, READONLY, ALIGN=2

                  HID_SetFirstInReport PROC
;;;459    /* This function is used to prepare the first in report */
;;;460    void HID_SetFirstInReport(void)
000000  b510              PUSH     {r4,lr}
;;;461    {
;;;462        DrvUSB_DataIn(INT_IN_EP_NUM_MS, g_HID_sDevice.pu8Report_MS, g_HID_sDevice.u32ReportSize_MS);
000002  4806              LDR      r0,|L6.28|
000004  6b42              LDR      r2,[r0,#0x34]  ; g_HID_sDevice
000006  6ac1              LDR      r1,[r0,#0x2c]  ; g_HID_sDevice
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       DrvUSB_DataIn
;;;463    		DrvUSB_DataIn(INT_IN_EP_NUM_KB, g_HID_sDevice.pu8Report_KB, g_HID_sDevice.u32ReportSize_KB);
00000e  4803              LDR      r0,|L6.28|
000010  6b82              LDR      r2,[r0,#0x38]  ; g_HID_sDevice
000012  6b01              LDR      r1,[r0,#0x30]  ; g_HID_sDevice
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       DrvUSB_DataIn
;;;464    }
00001a  bd10              POP      {r4,pc}
;;;465    
                          ENDP

                  |L6.28|
                          DCD      g_HID_sDevice

                          AREA ||i.HID_SetFirstOutReport||, CODE, READONLY, ALIGN=1

                  HID_SetFirstOutReport PROC
;;;453    /* This function is used to prepare the first out report. */
;;;454    void HID_SetFirstOutReport(void)
000000  4770              BX       lr
;;;455    {
;;;456    		
;;;457    }
;;;458    
                          ENDP


                          AREA ||i.HID_SetInReport_KB||, CODE, READONLY, ALIGN=2

                  HID_SetInReport_KB PROC
;;;393    
;;;394    void HID_SetInReport_KB()
000000  b5f8              PUSH     {r3-r7,lr}
;;;395    {
;;;396        uint8_t *buf;
;;;397        int32_t i;
;;;398        uint32_t key = 0xF;
000002  260f              MOVS     r6,#0xf
;;;399        uint32_t preKey =0xF;
000004  270f              MOVS     r7,#0xf
;;;400    	key=1;
000006  2601              MOVS     r6,#1
;;;401        /* To check if previous report data is processed or not */
;;;402        if(g_HID_sDevice.isReportReady_KB)
000008  482a              LDR      r0,|L8.180|
00000a  7f40              LDRB     r0,[r0,#0x1d]
00000c  2800              CMP      r0,#0
00000e  d000              BEQ      |L8.18|
                  |L8.16|
;;;403            return;
;;;404                                  
;;;405        buf = g_HID_sDevice.pu8Report_KB;
;;;406       if (key == 0)
;;;407    	{
;;;408    
;;;409    		buf[0] = 0x01;	/* Report ID */ 
;;;410    
;;;411    		for (i=1;i<9;i++)
;;;412    		{
;;;413    			buf[i] = 0;										 
;;;414    		}
;;;415    
;;;416    		if((key != preKey))
;;;417    		{
;;;418    			/* Trigger to note key release */
;;;419    	       g_HID_sDevice.isReportReady_KB = 1;
;;;420                DrvUSB_DataIn(INT_IN_EP_NUM_KB, g_HID_sDevice.pu8Report_KB, g_HID_sDevice.u32ReportSize_KB);
;;;421      		}
;;;422    	}
;;;423    	else if (key == 1)
;;;424    	{	
;;;425    		// Key A    2c =space      4f,50,51,52			  w=1a s=16 a=04 d=07
;;;426    		preKey = key;
;;;427    		buf[0] = 0x01;	/* Report ID */
;;;428    
;;;429    		if(comRbufk[0]=='1')
;;;430    			buf[3]=0x4f;
;;;431    		else if(comRbufk[0]=='2')
;;;432    			buf[3]=0x50;
;;;433    		else
;;;434    			buf[3]=0x00;
;;;435    
;;;436    		if(comRbufk[1]=='1')
;;;437    			buf[4]=0x51;
;;;438    		else if(comRbufk[1]=='2')
;;;439    			buf[4]=0x52;										  
;;;440    		else
;;;441    			buf[4]=0x00;
;;;442    
;;;443    		if(comRbufk[0]=='5') 
;;;444    			buf[3] = 0x2c; 
;;;445    			  //DrvSYS_Delay(2000);	
;;;446    	  	g_HID_sDevice.isReportReady_KB = 1;
;;;447            DrvUSB_DataIn(INT_IN_EP_NUM_KB, g_HID_sDevice.pu8Report_KB, g_HID_sDevice.u32ReportSize_KB);
;;;448    	
;;;449    	}  
;;;450    }
000010  bdf8              POP      {r3-r7,pc}
                  |L8.18|
000012  4828              LDR      r0,|L8.180|
000014  3820              SUBS     r0,r0,#0x20           ;405
000016  6b04              LDR      r4,[r0,#0x30]         ;405  ; g_HID_sDevice
000018  2e00              CMP      r6,#0                 ;406
00001a  d114              BNE      |L8.70|
00001c  2001              MOVS     r0,#1                 ;409
00001e  7020              STRB     r0,[r4,#0]            ;409
000020  2501              MOVS     r5,#1                 ;411
000022  e002              B        |L8.42|
                  |L8.36|
000024  2000              MOVS     r0,#0                 ;413
000026  5560              STRB     r0,[r4,r5]            ;413
000028  1c6d              ADDS     r5,r5,#1              ;411
                  |L8.42|
00002a  2d09              CMP      r5,#9                 ;411
00002c  dbfa              BLT      |L8.36|
00002e  42be              CMP      r6,r7                 ;416
000030  d03d              BEQ      |L8.174|
000032  2101              MOVS     r1,#1                 ;419
000034  481f              LDR      r0,|L8.180|
000036  7741              STRB     r1,[r0,#0x1d]         ;419
000038  3820              SUBS     r0,r0,#0x20           ;420
00003a  6b82              LDR      r2,[r0,#0x38]         ;420  ; g_HID_sDevice
00003c  6b01              LDR      r1,[r0,#0x30]         ;420  ; g_HID_sDevice
00003e  2002              MOVS     r0,#2                 ;420
000040  f7fffffe          BL       DrvUSB_DataIn
000044  e033              B        |L8.174|
                  |L8.70|
000046  2e01              CMP      r6,#1                 ;423
000048  d131              BNE      |L8.174|
00004a  4637              MOV      r7,r6                 ;426
00004c  2001              MOVS     r0,#1                 ;427
00004e  7020              STRB     r0,[r4,#0]            ;427
000050  4819              LDR      r0,|L8.184|
000052  7800              LDRB     r0,[r0,#0]            ;429  ; comRbufk
000054  2831              CMP      r0,#0x31              ;429
000056  d102              BNE      |L8.94|
000058  204f              MOVS     r0,#0x4f              ;430
00005a  70e0              STRB     r0,[r4,#3]            ;430
00005c  e008              B        |L8.112|
                  |L8.94|
00005e  4816              LDR      r0,|L8.184|
000060  7800              LDRB     r0,[r0,#0]            ;431  ; comRbufk
000062  2832              CMP      r0,#0x32              ;431
000064  d102              BNE      |L8.108|
000066  2050              MOVS     r0,#0x50              ;432
000068  70e0              STRB     r0,[r4,#3]            ;432
00006a  e001              B        |L8.112|
                  |L8.108|
00006c  2000              MOVS     r0,#0                 ;434
00006e  70e0              STRB     r0,[r4,#3]            ;434
                  |L8.112|
000070  4811              LDR      r0,|L8.184|
000072  7840              LDRB     r0,[r0,#1]            ;436  ; comRbufk
000074  2831              CMP      r0,#0x31              ;436
000076  d102              BNE      |L8.126|
000078  2051              MOVS     r0,#0x51              ;437
00007a  7120              STRB     r0,[r4,#4]            ;437
00007c  e008              B        |L8.144|
                  |L8.126|
00007e  480e              LDR      r0,|L8.184|
000080  7840              LDRB     r0,[r0,#1]            ;438  ; comRbufk
000082  2832              CMP      r0,#0x32              ;438
000084  d102              BNE      |L8.140|
000086  2052              MOVS     r0,#0x52              ;439
000088  7120              STRB     r0,[r4,#4]            ;439
00008a  e001              B        |L8.144|
                  |L8.140|
00008c  2000              MOVS     r0,#0                 ;441
00008e  7120              STRB     r0,[r4,#4]            ;441
                  |L8.144|
000090  4809              LDR      r0,|L8.184|
000092  7800              LDRB     r0,[r0,#0]            ;443  ; comRbufk
000094  2835              CMP      r0,#0x35              ;443
000096  d101              BNE      |L8.156|
000098  202c              MOVS     r0,#0x2c              ;444
00009a  70e0              STRB     r0,[r4,#3]            ;444
                  |L8.156|
00009c  2101              MOVS     r1,#1                 ;446
00009e  4805              LDR      r0,|L8.180|
0000a0  7741              STRB     r1,[r0,#0x1d]         ;446
0000a2  3820              SUBS     r0,r0,#0x20           ;447
0000a4  6b82              LDR      r2,[r0,#0x38]         ;447  ; g_HID_sDevice
0000a6  6b01              LDR      r1,[r0,#0x30]         ;447  ; g_HID_sDevice
0000a8  2002              MOVS     r0,#2                 ;447
0000aa  f7fffffe          BL       DrvUSB_DataIn
                  |L8.174|
0000ae  bf00              NOP      
0000b0  e7ae              B        |L8.16|
;;;451    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L8.180|
                          DCD      g_HID_sDevice+0x20
                  |L8.184|
                          DCD      comRbufk

                          AREA ||i.HID_SetInReport_MS||, CODE, READONLY, ALIGN=2

                  HID_SetInReport_MS PROC
;;;370    /* This function is used to prepare IN report. The g_HID_sDevice.u32ReportSize will be reset when it has been done. */
;;;371    void HID_SetInReport_MS()
000000  b510              PUSH     {r4,lr}
;;;372    {
;;;373        uint8_t *buf;
;;;374    	
;;;375        /* To check if previous report data is processed or not */
;;;376        if(g_HID_sDevice.isReportReady_MS)
000002  4810              LDR      r0,|L9.68|
000004  7f00              LDRB     r0,[r0,#0x1c]
000006  2800              CMP      r0,#0
000008  d000              BEQ      |L9.12|
                  |L9.10|
;;;377            return;
;;;378    
;;;379        buf = g_HID_sDevice.pu8Report_MS;
;;;380    
;;;381       	buf[0] = atoi(comRbuf3); 	
;;;382    	buf[1] = -atoi(comRbuf); 
;;;383    	buf[2] = -atoi(comRbuf2); 
;;;384    //	comRbuf[0]=0;
;;;385    //	comRbuf[1]=0;
;;;386    //	comRbuf[2]=0;
;;;387    //	comRbuf2[0]=0;
;;;388    //	comRbuf2[1]=0;
;;;389    //	comRbuf2[2]=0;
;;;390        g_HID_sDevice.isReportReady_MS = 1; /* To note the report data has been updated */
;;;391        DrvUSB_DataIn(INT_IN_EP_NUM_MS, g_HID_sDevice.pu8Report_MS, g_HID_sDevice.u32ReportSize_MS);
;;;392    }
00000a  bd10              POP      {r4,pc}
                  |L9.12|
00000c  480d              LDR      r0,|L9.68|
00000e  3820              SUBS     r0,r0,#0x20           ;379
000010  6ac4              LDR      r4,[r0,#0x2c]         ;379  ; g_HID_sDevice
000012  480d              LDR      r0,|L9.72|
000014  f7fffffe          BL       atoi
000018  7020              STRB     r0,[r4,#0]            ;381
00001a  480c              LDR      r0,|L9.76|
00001c  f7fffffe          BL       atoi
000020  4240              RSBS     r0,r0,#0              ;382
000022  7060              STRB     r0,[r4,#1]            ;382
000024  480a              LDR      r0,|L9.80|
000026  f7fffffe          BL       atoi
00002a  4240              RSBS     r0,r0,#0              ;383
00002c  70a0              STRB     r0,[r4,#2]            ;383
00002e  2101              MOVS     r1,#1                 ;390
000030  4804              LDR      r0,|L9.68|
000032  7701              STRB     r1,[r0,#0x1c]         ;390
000034  3820              SUBS     r0,r0,#0x20           ;391
000036  6b42              LDR      r2,[r0,#0x34]         ;391  ; g_HID_sDevice
000038  6ac1              LDR      r1,[r0,#0x2c]         ;391  ; g_HID_sDevice
00003a  2001              MOVS     r0,#1                 ;391
00003c  f7fffffe          BL       DrvUSB_DataIn
000040  bf00              NOP      
000042  e7e2              B        |L9.10|
;;;393    
                          ENDP

                  |L9.68|
                          DCD      g_HID_sDevice+0x20
                  |L9.72|
                          DCD      comRbuf3
                  |L9.76|
                          DCD      comRbuf
                  |L9.80|
                          DCD      comRbuf2

                          AREA ||i.PowerDown||, CODE, READONLY, ALIGN=2

                  PowerDown PROC
;;;473    
;;;474    void PowerDown()
000000  b510              PUSH     {r4,lr}
;;;475    {
;;;476        DBG_PRINTF("Enter power down ...\n");
000002  a02a              ADR      r0,|L10.172|
000004  f7fffffe          BL       __2printf
;;;477    
;;;478        UNLOCKREG();
000008  2059              MOVS     r0,#0x59
00000a  492e              LDR      r1,|L10.196|
00000c  6008              STR      r0,[r1,#0]
00000e  2016              MOVS     r0,#0x16
000010  6008              STR      r0,[r1,#0]
000012  2088              MOVS     r0,#0x88
000014  6008              STR      r0,[r1,#0]
;;;479    
;;;480        while ( IsDebugFifoEmpty() == FALSE );
000016  bf00              NOP      
                  |L10.24|
000018  f7fffffe          BL       IsDebugFifoEmpty
00001c  2800              CMP      r0,#0
00001e  d0fb              BEQ      |L10.24|
;;;481        
;;;482        /* Wakeup Enable */
;;;483        USBD->INTEN.WAKEUP_EN = 1;
000020  4829              LDR      r0,|L10.200|
000022  6800              LDR      r0,[r0,#0]
000024  21ff              MOVS     r1,#0xff
000026  3101              ADDS     r1,#1
000028  4388              BICS     r0,r0,r1
00002a  1840              ADDS     r0,r0,r1
00002c  4926              LDR      r1,|L10.200|
00002e  6008              STR      r0,[r1,#0]
;;;484    
;;;485        /* Deep sleep */
;;;486        outp32(0xE000ED10, 4);
000030  2004              MOVS     r0,#4
000032  4926              LDR      r1,|L10.204|
000034  6108              STR      r0,[r1,#0x10]
;;;487        SYSCLK->PWRCON.PD_WAIT_CPU = 1;
000036  4826              LDR      r0,|L10.208|
000038  6800              LDR      r0,[r0,#0]
00003a  21ff              MOVS     r1,#0xff
00003c  3101              ADDS     r1,#1
00003e  4388              BICS     r0,r0,r1
000040  1840              ADDS     r0,r0,r1
000042  4923              LDR      r1,|L10.208|
000044  6008              STR      r0,[r1,#0]
;;;488        SYSCLK->PWRCON.PWR_DOWN_EN = 1;
000046  4608              MOV      r0,r1
000048  6800              LDR      r0,[r0,#0]
00004a  2180              MOVS     r1,#0x80
00004c  4388              BICS     r0,r0,r1
00004e  3080              ADDS     r0,r0,#0x80
000050  491f              LDR      r1,|L10.208|
000052  6008              STR      r0,[r1,#0]
;;;489        __WFI();
000054  bf30              WFI      
;;;490        SYSCLK->PWRCON.PWR_DOWN_EN = 0;
000056  4608              MOV      r0,r1
000058  6800              LDR      r0,[r0,#0]
00005a  2180              MOVS     r1,#0x80
00005c  4388              BICS     r0,r0,r1
00005e  491c              LDR      r1,|L10.208|
000060  6008              STR      r0,[r1,#0]
;;;491    
;;;492        if(DrvUSB_GetUsbState() & eDRVUSB_SUSPENDED)
000062  f7fffffe          BL       DrvUSB_GetUsbState
000066  2120              MOVS     r1,#0x20
000068  4208              TST      r0,r1
00006a  d01b              BEQ      |L10.164|
;;;493        {
;;;494            /* Note HOST to resume USB tree if it is suspended and remote wakeup enabled */
;;;495            if(DrvUSB_IsRemoteWakeupEnabled())
00006c  f7fffffe          BL       DrvUSB_IsRemoteWakeupEnabled
000070  2800              CMP      r0,#0
000072  d017              BEQ      |L10.164|
;;;496            {
;;;497                /* Enable PHY before sending Resume('K') state */
;;;498                USBD->ATTR.PHY_EN = 1;
000074  4814              LDR      r0,|L10.200|
000076  6900              LDR      r0,[r0,#0x10]
000078  2110              MOVS     r1,#0x10
00007a  4388              BICS     r0,r0,r1
00007c  3010              ADDS     r0,r0,#0x10
00007e  4912              LDR      r1,|L10.200|
000080  6108              STR      r0,[r1,#0x10]
;;;499    
;;;500                /* Keep remote wakeup for 1 ms */
;;;501                USBD->ATTR.RWAKEUP = 1;
000082  4608              MOV      r0,r1
000084  6900              LDR      r0,[r0,#0x10]
000086  2120              MOVS     r1,#0x20
000088  4388              BICS     r0,r0,r1
00008a  3020              ADDS     r0,r0,#0x20
00008c  490e              LDR      r1,|L10.200|
00008e  6108              STR      r0,[r1,#0x10]
;;;502                DrvSYS_Delay(1000); /* Delay 1ms */
000090  207d              MOVS     r0,#0x7d
000092  00c0              LSLS     r0,r0,#3
000094  f7fffffe          BL       DrvSYS_Delay
;;;503                USBD->ATTR.RWAKEUP = 0;
000098  480b              LDR      r0,|L10.200|
00009a  6900              LDR      r0,[r0,#0x10]
00009c  2120              MOVS     r1,#0x20
00009e  4388              BICS     r0,r0,r1
0000a0  4909              LDR      r1,|L10.200|
0000a2  6108              STR      r0,[r1,#0x10]
                  |L10.164|
;;;504            }
;;;505        }
;;;506    
;;;507        DBG_PRINTF("device wakeup!\n");
0000a4  a00b              ADR      r0,|L10.212|
0000a6  f7fffffe          BL       __2printf
;;;508        
;;;509    }
0000aa  bd10              POP      {r4,pc}
;;;510    
                          ENDP

                  |L10.172|
0000ac  456e7465          DCB      "Enter power down ...\n",0
0000b0  7220706f
0000b4  77657220
0000b8  646f776e
0000bc  202e2e2e
0000c0  0a00    
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L10.196|
                          DCD      0x50000100
                  |L10.200|
                          DCD      0x40060000
                  |L10.204|
                          DCD      0xe000ed00
                  |L10.208|
                          DCD      0x50000200
                  |L10.212|
0000d4  64657669          DCB      "device wakeup!\n",0
0000d8  63652077
0000dc  616b6575
0000e0  70210a00

                          AREA ||i.UART_INT_HANDLE||, CODE, READONLY, ALIGN=2

                  UART_INT_HANDLE PROC
;;;510    
;;;511    void UART_INT_HANDLE(void)
000000  b538              PUSH     {r3-r5,lr}
;;;512    {
;;;513    	uint8_t bInChar[1] = {0xFF};
000002  a025              ADR      r0,|L11.152|
000004  6800              LDR      r0,[r0,#0]
000006  9000              STR      r0,[sp,#0]
;;;514    	int i=0;
000008  2400              MOVS     r4,#0
;;;515    
;;;516    	while(UART0->ISR.RDA_IF==1) 
00000a  e03c              B        |L11.134|
                  |L11.12|
;;;517    	{
;;;518    		DrvUART_Read(UART_PORT0,bInChar,1);	
00000c  2201              MOVS     r2,#1
00000e  4669              MOV      r1,sp
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       DrvUART_Read
;;;519    		if(bInChar[0]=='s') // check if Buffer is full
000016  4668              MOV      r0,sp
000018  7800              LDRB     r0,[r0,#0]
00001a  2873              CMP      r0,#0x73
00001c  d133              BNE      |L11.134|
;;;520    		{
;;;521    		    DrvUART_Read(UART_PORT0,bInChar,1);	
00001e  2201              MOVS     r2,#1
000020  4669              MOV      r1,sp
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       DrvUART_Read
;;;522    			while(bInChar[0]!='t')
000028  e009              B        |L11.62|
                  |L11.42|
;;;523    			{
;;;524    				comRbuf[i] = bInChar[0];
00002a  4668              MOV      r0,sp
00002c  7800              LDRB     r0,[r0,#0]
00002e  491b              LDR      r1,|L11.156|
000030  5508              STRB     r0,[r1,r4]
;;;525    				i++;	
000032  1c64              ADDS     r4,r4,#1
;;;526    				DrvUART_Read(UART_PORT0,bInChar,1);	
000034  2201              MOVS     r2,#1
000036  4669              MOV      r1,sp
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       DrvUART_Read
                  |L11.62|
00003e  4668              MOV      r0,sp                 ;522
000040  7800              LDRB     r0,[r0,#0]            ;522
000042  2874              CMP      r0,#0x74              ;522
000044  d1f1              BNE      |L11.42|
;;;527    			}
;;;528    			i=0;
000046  2400              MOVS     r4,#0
;;;529    			DrvUART_Read(UART_PORT0,bInChar,1);	
000048  2201              MOVS     r2,#1
00004a  4669              MOV      r1,sp
00004c  2000              MOVS     r0,#0
00004e  f7fffffe          BL       DrvUART_Read
;;;530    			while(bInChar[0]!='a')
000052  e009              B        |L11.104|
                  |L11.84|
;;;531    			{
;;;532    				comRbuf2[i] = bInChar[0];
000054  4668              MOV      r0,sp
000056  7800              LDRB     r0,[r0,#0]
000058  4911              LDR      r1,|L11.160|
00005a  5508              STRB     r0,[r1,r4]
;;;533    				i++;	
00005c  1c64              ADDS     r4,r4,#1
;;;534    				DrvUART_Read(UART_PORT0,bInChar,1);	
00005e  2201              MOVS     r2,#1
000060  4669              MOV      r1,sp
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       DrvUART_Read
                  |L11.104|
000068  4668              MOV      r0,sp                 ;530
00006a  7800              LDRB     r0,[r0,#0]            ;530
00006c  2861              CMP      r0,#0x61              ;530
00006e  d1f1              BNE      |L11.84|
;;;535    			}
;;;536    			DrvUART_Read(UART_PORT0,bInChar,1);	
000070  2201              MOVS     r2,#1
000072  4669              MOV      r1,sp
000074  2000              MOVS     r0,#0
000076  f7fffffe          BL       DrvUART_Read
;;;537    			comRbuf3[0] = bInChar[0];
00007a  4668              MOV      r0,sp
00007c  7800              LDRB     r0,[r0,#0]
00007e  4909              LDR      r1,|L11.164|
000080  7008              STRB     r0,[r1,#0]
;;;538    			i=0;
000082  2400              MOVS     r4,#0
;;;539    			break;
000084  e005              B        |L11.146|
                  |L11.134|
000086  4808              LDR      r0,|L11.168|
000088  69c0              LDR      r0,[r0,#0x1c]         ;516
00008a  07c0              LSLS     r0,r0,#31             ;516
00008c  0fc0              LSRS     r0,r0,#31             ;516
00008e  2801              CMP      r0,#1                 ;516
000090  d0bc              BEQ      |L11.12|
                  |L11.146|
000092  bf00              NOP      
;;;540    		}
;;;541    	}
;;;542    
;;;543    
;;;544    //	while(UART0->ISR.RDA_IF==1) 
;;;545    //	{
;;;546    //		DrvUART_Read(UART_PORT0,bInChar,1);	
;;;547    //		if(bInChar[0]=='s') // check if Buffer is full
;;;548    //		{
;;;549    //			DrvUART_Read(UART_PORT0,bInChar,1);	
;;;550    //			comRbufk[0] = bInChar[0];
;;;551    //			DrvUART_Read(UART_PORT0,bInChar,1);	
;;;552    //			comRbufk[1] = bInChar[0];
;;;553    //			sprintf(TEXT2+4,"%s",comRbuf);
;;;554    //			print_lcd(2,TEXT2);
;;;555    //		}	
;;;556    //	}
;;;557    
;;;558    }
000094  bd38              POP      {r3-r5,pc}
;;;559    
                          ENDP

000096  0000              DCW      0x0000
                  |L11.152|
000098  ff00              DCB      255,0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L11.156|
                          DCD      comRbuf
                  |L11.160|
                          DCD      comRbuf2
                  |L11.164|
                          DCD      comRbuf3
                  |L11.168|
                          DCD      0x40050000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_au8KeyboardReport
                          %        9

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_sVendorStringDesc
000000  1003              DCB      0x10,0x03
000002  004e              DCW      0x004e
000004  00550056          DCW      0x0055,0x0056
000008  004f0054          DCW      0x004f,0x0054
00000c  004f004e          DCW      0x004f,0x004e
                          %        184
0000c8  0000              DCB      0x00,0x00
                  g_sProductStringDesc
0000ca  1603              DCB      0x16,0x03
0000cc  00410052          DCW      0x0041,0x0052
0000d0  004d0020          DCW      0x004d,0x0020
0000d4  00730065          DCW      0x0073,0x0065
0000d8  00720069          DCW      0x0072,0x0069
0000dc  00650073          DCW      0x0065,0x0073
                          %        180
                  g_HID_au8MouseReportDescriptor
000194  05010902          DCB      0x05,0x01,0x09,0x02
000198  a1010901          DCB      0xa1,0x01,0x09,0x01
00019c  a1000509          DCB      0xa1,0x00,0x05,0x09
0001a0  19012903          DCB      0x19,0x01,0x29,0x03
0001a4  15002501          DCB      0x15,0x00,0x25,0x01
0001a8  95037501          DCB      0x95,0x03,0x75,0x01
0001ac  81029501          DCB      0x81,0x02,0x95,0x01
0001b0  75058101          DCB      0x75,0x05,0x81,0x01
0001b4  05010930          DCB      0x05,0x01,0x09,0x30
0001b8  09311581          DCB      0x09,0x31,0x15,0x81
0001bc  257f7508          DCB      0x25,0x7f,0x75,0x08
0001c0  95028106          DCB      0x95,0x02,0x81,0x06
0001c4  c0c00000          DCB      0xc0,0xc0,0x00,0x00
                  g_HID_u32MouseReportDescriptorSize
                          DCD      0x00000032
                  g_u32MouseReportSize
                          DCD      0x00000003
                  g_HID_au8KeyboardReportDescriptor
0001d0  05010906          DCB      0x05,0x01,0x09,0x06
0001d4  a1018501          DCB      0xa1,0x01,0x85,0x01
0001d8  050719e0          DCB      0x05,0x07,0x19,0xe0
0001dc  29e71500          DCB      0x29,0xe7,0x15,0x00
0001e0  25017501          DCB      0x25,0x01,0x75,0x01
0001e4  95088102          DCB      0x95,0x08,0x81,0x02
0001e8  95017508          DCB      0x95,0x01,0x75,0x08
0001ec  81019505          DCB      0x81,0x01,0x95,0x05
0001f0  75010508          DCB      0x75,0x01,0x05,0x08
0001f4  19012905          DCB      0x19,0x01,0x29,0x05
0001f8  91029501          DCB      0x91,0x02,0x95,0x01
0001fc  75039101          DCB      0x75,0x03,0x91,0x01
000200  95067508          DCB      0x95,0x06,0x75,0x08
000204  15002565          DCB      0x15,0x00,0x25,0x65
000208  05071900          DCB      0x05,0x07,0x19,0x00
00020c  29658100          DCB      0x29,0x65,0x81,0x00
000210  c0050c09          DCB      0xc0,0x05,0x0c,0x09
000214  01a10185          DCB      0x01,0xa1,0x01,0x85
000218  02150025          DCB      0x02,0x15,0x00,0x25
00021c  0109e209          DCB      0x01,0x09,0xe2,0x09
000220  e909ea09          DCB      0xe9,0x09,0xea,0x09
000224  6f097075          DCB      0x6f,0x09,0x70,0x75
000228  01950581          DCB      0x01,0x95,0x05,0x81
00022c  02050109          DCB      0x02,0x05,0x01,0x09
000230  82750195          DCB      0x82,0x75,0x01,0x95
000234  01810275          DCB      0x01,0x81,0x02,0x75
000238  01950281          DCB      0x01,0x95,0x02,0x81
00023c  03c00000          DCB      0x03,0xc0,0x00,0x00
                  g_HID_u32KeyboardReportDescriptorSize
                          DCD      0x0000006e
                  g_u32KeyboardReportSize
                          DCD      0x00000009
                  g_HID_au8DeviceDescriptor
000248  12011001          DCB      0x12,0x01,0x10,0x01
00024c  00000008          DCB      0x00,0x00,0x00,0x08
000250  160442c1          DCB      0x16,0x04,0x42,0xc1
000254  00000102          DCB      0x00,0x00,0x01,0x02
000258  0001              DCB      0x00,0x01
                  g_HID_au8ConfigDescriptor
00025a  0902              DCB      0x09,0x02
00025c  3b000201          DCB      0x3b,0x00,0x02,0x01
000260  00a03209          DCB      0x00,0xa0,0x32,0x09
000264  04000001          DCB      0x04,0x00,0x00,0x01
000268  03010200          DCB      0x03,0x01,0x02,0x00
00026c  09211001          DCB      0x09,0x21,0x10,0x01
000270  00012232          DCB      0x00,0x01,0x22,0x32
000274  00070581          DCB      0x00,0x07,0x05,0x81
000278  03400014          DCB      0x03,0x40,0x00,0x14
00027c  09040100          DCB      0x09,0x04,0x01,0x00
000280  01030101          DCB      0x01,0x03,0x01,0x01
000284  00092110          DCB      0x00,0x09,0x21,0x10
000288  01000122          DCB      0x01,0x00,0x01,0x22
00028c  6e000705          DCB      0x6e,0x00,0x07,0x05
000290  82034000          DCB      0x82,0x03,0x40,0x00
000294  14                DCB      0x14
                  g_HID_au8StringLang
000295  040309            DCB      0x04,0x03,0x09
000298  0400              DCB      0x04,0x00
                  g_HID_sVendorStringDesc
00029a  1003              DCB      0x10,0x03
00029c  004e0055          DCW      0x004e,0x0055
0002a0  0056004f          DCW      0x0056,0x004f
0002a4  0054004f          DCW      0x0054,0x004f
0002a8  004e              DCW      0x004e
0002aa  0000              DCB      0x00,0x00
                          %        184
                  g_HID_sProductStringDesc
000364  1003              DCB      0x10,0x03
000366  0057              DCW      0x0057
000368  0050004d          DCW      0x0050,0x004d
00036c  00200055          DCW      0x0020,0x0055
000370  00530042          DCW      0x0053,0x0042
                          %        184
00042c  0000              DCB      0x00,0x00
                  g_HID_au8StringSerial
00042e  1a03              DCB      0x1a,0x03
000430  42003000          DCB      0x42,0x00,0x30,0x00
000434  32003000          DCB      0x32,0x00,0x30,0x00
000438  30003600          DCB      0x30,0x00,0x36,0x00
00043c  30003900          DCB      0x30,0x00,0x39,0x00
000440  32003100          DCB      0x32,0x00,0x31,0x00
000444  31003400          DCB      0x31,0x00,0x34,0x00

                          AREA ||.data||, DATA, ALIGN=1

                  comRbuf
000000  30000000          DCB      0x30,0x00,0x00,0x00
                          %        12
                  comRbuf2
000010  30000000          DCB      0x30,0x00,0x00,0x00
                          %        12
                  comRbuf3
000020  30000000          DCB      0x30,0x00,0x00,0x00
                          %        12
                  comRbufk
000030  30000000          DCB      0x30,0x00,0x00,0x00
                          %        12
                  TEXT1
000040  54583a20          DCB      0x54,0x58,0x3a,0x20
000044  73656e64          DCB      0x73,0x65,0x6e,0x64
000048  696e672e          DCB      0x69,0x6e,0x67,0x2e
00004c  2e2e2020          DCB      0x2e,0x2e,0x20,0x20
                  TEXT2
000050  52583a20          DCB      0x52,0x58,0x3a,0x20
000054  20202020          DCB      0x20,0x20,0x20,0x20
000058  20202000          DCB      0x20,0x20,0x20,0x00
                          DCDU     0x00000000
                  comRbytes
000060  0000              DCW      0x0000
                  comRhead
000062  0000              DCW      0x0000
                  comRtail
000064  0000              DCW      0x0000
                  g_au8MouseReport
000066  0000              DCB      0x00,0x00
000068  00                DCB      0x00
