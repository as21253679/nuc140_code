; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\hid_api.o --depend=.\obj\hid_api.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\ -I..\..\..\..\CMSIS\CM0\CoreSupport -I..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx -I..\..\..\Include -I..\..\..\Include\Driver -I..\..\..\Include\NUC1xx-LB_002 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\hid_api.crf HID_API.c]
                          THUMB

                          AREA ||i.DrvUSB_BusResumeCallback||, CODE, READONLY, ALIGN=1

                  DrvUSB_BusResumeCallback PROC
;;;891    
;;;892    void DrvUSB_BusResumeCallback(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;893    {
000002  4605              MOV      r5,r0
;;;894    	DrvUSB_SetUsbState((E_DRVUSB_STATE)((uint32_t)DrvUSB_GetUsbState() & (uint32_t)(~eDRVUSB_SUSPENDED)));
000004  f7fffffe          BL       DrvUSB_GetUsbState
000008  2120              MOVS     r1,#0x20
00000a  4388              BICS     r0,r0,r1
00000c  4604              MOV      r4,r0
00000e  f7fffffe          BL       DrvUSB_SetUsbState
;;;895    }
000012  bd70              POP      {r4-r6,pc}
;;;896    
                          ENDP


                          AREA ||i.DrvUSB_BusSuspendCallback||, CODE, READONLY, ALIGN=1

                  DrvUSB_BusSuspendCallback PROC
;;;885    
;;;886    void DrvUSB_BusSuspendCallback(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;887    {
000002  4605              MOV      r5,r0
;;;888    	/* Note!! We should not power down or idle in Handler mode */
;;;889    	DrvUSB_SetUsbState((E_DRVUSB_STATE)((uint32_t)DrvUSB_GetUsbState() | (uint32_t)eDRVUSB_SUSPENDED));
000004  f7fffffe          BL       DrvUSB_GetUsbState
000008  2120              MOVS     r1,#0x20
00000a  4308              ORRS     r0,r0,r1
00000c  4604              MOV      r4,r0
00000e  f7fffffe          BL       DrvUSB_SetUsbState
;;;890    }
000012  bd70              POP      {r4-r6,pc}
;;;891    
                          ENDP


                          AREA ||i.HID_GetOutReportAck||, CODE, READONLY, ALIGN=1

                  HID_GetOutReportAck PROC
;;;745    Therefore, we could prepare next out report here. */
;;;746    void HID_GetOutReportAck(uint8_t *buf, uint32_t size)
000000  4770              BX       lr
;;;747    {
;;;748    
;;;749    }
;;;750    
                          ENDP


                          AREA ||i.HID_Init||, CODE, READONLY, ALIGN=2

                  HID_Init PROC
;;;463    
;;;464    void HID_Init(void)
000000  b510              PUSH     {r4,lr}
;;;465    {
;;;466    	/* Open HID to initial the descriptors and control handlers */
;;;467    	HID_Open();
000002  f7fffffe          BL       HID_Open
;;;468    
;;;469    #if(HID_FUNCTION == HID_MOUSE)
;;;470    
;;;471    	/* Set the HID report descriptor */
;;;472    	HID_SetReportDescriptor(g_HID_au8MouseReportDescriptor, g_HID_u32MouseReportDescriptorSize);
000006  2132              MOVS     r1,#0x32
000008  4803              LDR      r0,|L4.24|
00000a  f7fffffe          BL       HID_SetReportDescriptor
;;;473    
;;;474    	/* Set the HID report buffer */
;;;475    	HID_SetReportBuf(g_au8MouseReport, g_u32MouseReportSize);
00000e  2103              MOVS     r1,#3
000010  4802              LDR      r0,|L4.28|
000012  f7fffffe          BL       HID_SetReportBuf
;;;476    
;;;477    #elif(HID_FUNCTION == HID_DIGITIZER)
;;;478    	/* Set the HID report descriptor */
;;;479    	HID_SetReportDescriptor(g_HID_au8DigitizerReportDescriptor, g_HID_u32DigitizerReportDescriptorSize);
;;;480    
;;;481    	/* Set the HID report buffer */
;;;482    	HID_SetReportBuf(g_au8DigitizerReport, g_u32DigitizerReportSize);
;;;483    #else
;;;484    	/* Set the HID report descriptor */
;;;485    	HID_SetReportDescriptor(g_HID_au8KeyboardReportDescriptor, g_HID_u32KeyboardReportDescriptorSize);
;;;486    
;;;487    	/* Set the HID report buffer */
;;;488    	HID_SetReportBuf(g_au8KeyboardReport, g_u32KeyboardReportSize);
;;;489    #endif
;;;490    
;;;491    }
000016  bd10              POP      {r4,pc}
;;;492    
                          ENDP

                  |L4.24|
                          DCD      g_HID_au8MouseReportDescriptor
                  |L4.28|
                          DCD      g_au8MouseReport

                          AREA ||i.HID_MainProcess||, CODE, READONLY, ALIGN=2

                  HID_MainProcess PROC
;;;819    
;;;820    int32_t HID_MainProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;821    {
;;;822    
;;;823    	int32_t i32Ret = 0;
000002  2500              MOVS     r5,#0
;;;824    	E_DRVUSB_STATE eUsbState;
;;;825    
;;;826    	//GPIOD->IEN = (1 << 1);
;;;827    	NVIC_EnableIRQ(GPCDE_IRQn);
000004  bf00              NOP      
000006  2005              MOVS     r0,#5
000008  2101              MOVS     r1,#1
00000a  4081              LSLS     r1,r1,r0
00000c  4819              LDR      r0,|L5.116|
00000e  6001              STR      r1,[r0,#0]
000010  bf00              NOP      
;;;828    
;;;829    	i32Ret = DrvUSB_Open((void *)DrvUSB_DispatchEvent);
000012  4819              LDR      r0,|L5.120|
000014  f7fffffe          BL       DrvUSB_Open
000018  4605              MOV      r5,r0
;;;830    	if(i32Ret != 0)
00001a  2d00              CMP      r5,#0
00001c  d001              BEQ      |L5.34|
;;;831    		return i32Ret;
00001e  4628              MOV      r0,r5
;;;832    
;;;833    	DrvUART_EnableInt(UART_PORT0, DRVUART_RDAINT, UART_INT_HANDLE);  
;;;834    
;;;835    
;;;836    
;;;837    	while(1)
;;;838    	{
;;;839    		/* Disable USB-related interrupts. */
;;;840    		_DRVUSB_ENABLE_MISC_INT(0);
;;;841    
;;;842    		/* Enable float-detection interrupt. */
;;;843    		_DRVUSB_ENABLE_FLDET_INT();
;;;844    
;;;845    		/* Start HID and install the callback functions to handle in/out report */
;;;846    		HID_Init();
;;;847    
;;;848    		/* Enable USB-related interrupts. */
;;;849    		_DRVUSB_ENABLE_MISC_INT(INTEN_WAKEUP | INTEN_WAKEUPEN | INTEN_FLDET | INTEN_USB | INTEN_BUS);
;;;850    
;;;851    		/* Enter power down to wait USB attached */
;;;852    		// PowerDown();
;;;853    
;;;854    		/* Poll and handle USB events. */
;;;855    		while(1)
;;;856    		{	
;;;857    
;;;858    			// show_string(0,10,"dx");
;;;859    			eUsbState = DrvUSB_GetUsbState();
;;;860    
;;;861    			if (eUsbState == eDRVUSB_DETACHED)
;;;862    			{	 
;;;863    				DBG_PRINTF("USB Detached!\n");
;;;864    				break;
;;;865    			}
;;;866    
;;;867    			if (eUsbState & eDRVUSB_SUSPENDED)
;;;868    			{	
;;;869    				/* Enter suspend here */
;;;870    				// PowerDown();
;;;871    			}
;;;872    
;;;873    			if (eUsbState == eDRVUSB_CONFIGURED)
;;;874    			{	 
;;;875    				/* Set HID IN report for interrupt IN transfer */
;;;876    
;;;877    				HID_SetInReport();
;;;878    			}
;;;879    		}
;;;880    
;;;881    		/* Disable USB-related interrupts. */
;;;882    		_DRVUSB_ENABLE_MISC_INT(0);
;;;883    	}
;;;884    }
000020  bd70              POP      {r4-r6,pc}
                  |L5.34|
000022  4a16              LDR      r2,|L5.124|
000024  2101              MOVS     r1,#1                 ;833
000026  2000              MOVS     r0,#0                 ;833
000028  f7fffffe          BL       DrvUART_EnableInt
00002c  e021              B        |L5.114|
                  |L5.46|
00002e  2000              MOVS     r0,#0                 ;840
000030  4913              LDR      r1,|L5.128|
000032  6008              STR      r0,[r1,#0]            ;840
000034  4608              MOV      r0,r1                 ;843
000036  6800              LDR      r0,[r0,#0]            ;843
000038  2104              MOVS     r1,#4                 ;843
00003a  4388              BICS     r0,r0,r1              ;843
00003c  1d00              ADDS     r0,r0,#4              ;843
00003e  4910              LDR      r1,|L5.128|
000040  6008              STR      r0,[r1,#0]            ;843
000042  f7fffffe          BL       HID_Init
000046  200f              MOVS     r0,#0xf               ;849
000048  490d              LDR      r1,|L5.128|
00004a  6008              STR      r0,[r1,#0]            ;849
00004c  e00c              B        |L5.104|
                  |L5.78|
00004e  f7fffffe          BL       DrvUSB_GetUsbState
000052  4604              MOV      r4,r0                 ;859
000054  2c00              CMP      r4,#0                 ;861
000056  d103              BNE      |L5.96|
000058  a00a              ADR      r0,|L5.132|
00005a  f7fffffe          BL       __2printf
00005e  e004              B        |L5.106|
                  |L5.96|
000060  2c1f              CMP      r4,#0x1f              ;873
000062  d101              BNE      |L5.104|
000064  f7fffffe          BL       HID_SetInReport
                  |L5.104|
000068  e7f1              B        |L5.78|
                  |L5.106|
00006a  bf00              NOP                            ;864
00006c  2000              MOVS     r0,#0                 ;882
00006e  4904              LDR      r1,|L5.128|
000070  6008              STR      r0,[r1,#0]            ;882
                  |L5.114|
000072  e7dc              B        |L5.46|
;;;885    
                          ENDP

                  |L5.116|
                          DCD      0xe000e100
                  |L5.120|
                          DCD      DrvUSB_DispatchEvent
                  |L5.124|
                          DCD      UART_INT_HANDLE
                  |L5.128|
                          DCD      0x40060000
                  |L5.132|
000084  55534220          DCB      "USB Detached!\n",0
000088  44657461
00008c  63686564
000090  210a00  
000093  00                DCB      0

                          AREA ||i.HID_SetFirstInReport||, CODE, READONLY, ALIGN=2

                  HID_SetFirstInReport PROC
;;;737    /* This function is used to prepare the first in report */
;;;738    void HID_SetFirstInReport(void)
000000  b510              PUSH     {r4,lr}
;;;739    {
;;;740    	DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);
000002  4803              LDR      r0,|L6.16|
000004  6a82              LDR      r2,[r0,#0x28]  ; g_HID_sDevice
000006  6a41              LDR      r1,[r0,#0x24]  ; g_HID_sDevice
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       DrvUSB_DataIn
;;;741    }
00000e  bd10              POP      {r4,pc}
;;;742    
                          ENDP

                  |L6.16|
                          DCD      g_HID_sDevice

                          AREA ||i.HID_SetFirstOutReport||, CODE, READONLY, ALIGN=1

                  HID_SetFirstOutReport PROC
;;;731    /* This function is used to prepare the first out report. */
;;;732    void HID_SetFirstOutReport(void)
000000  4770              BX       lr
;;;733    {
;;;734    
;;;735    }
;;;736    
                          ENDP


                          AREA ||i.HID_SetInReport||, CODE, READONLY, ALIGN=2

                  HID_SetInReport PROC
;;;495    /* This function is used to prepare IN report. The g_HID_sDevice.u32ReportSize will be reset when it has been done. */
;;;496    void HID_SetInReport()
000000  b570              PUSH     {r4-r6,lr}
;;;497    {	char x='a';
000002  2561              MOVS     r5,#0x61
;;;498    	uint8_t *buf;
;;;499    	/* To check if previous report data is processed or not */
;;;500    	if(g_HID_sDevice.isReportReady)
000004  4813              LDR      r0,|L8.84|
000006  7b00              LDRB     r0,[r0,#0xc]
000008  2800              CMP      r0,#0
00000a  d000              BEQ      |L8.14|
                  |L8.12|
;;;501    		return;
;;;502    
;;;503    	buf = g_HID_sDevice.pu8Report;
;;;504    
;;;505    	/* Move mouse when GPD1 == 0 */
;;;506    	//if ((GPIOD->PIN & (1 << 1)) == 0)
;;;507    	{
;;;508    	/*	if(comRbuf[0]=='1') 
;;;509    		{
;;;510    			buf[0] = 0x00; 	
;;;511    			buf[1] = 1; 	
;;;512    			buf[2] = 0x00; 	
;;;513    		}
;;;514    		else if(comRbuf[0]=='2') 
;;;515    		{
;;;516    			buf[0] = 0x00; 	
;;;517    			buf[1] = 0x00; 	
;;;518    			buf[2] = 0x01; 	
;;;519    		}
;;;520    		else if(comRbuf[0]=='3') 
;;;521    		{
;;;522    			//buf[0] = 0x06; 
;;;523    		}
;;;524    		else
;;;525    		{
;;;526    			buf[0] = 0x00; 	
;;;527    			buf[1] = 0x00; 	
;;;528    			buf[2] = 0x00; 	
;;;529    		}					*/
;;;530    		buf[0] = 0x01; 	
;;;531    		buf[1] = -atoi(comRbuf); 
;;;532    		buf[2] = -atoi(comRbuf2); 
;;;533    		comRbuf[0]=0;
;;;534    		comRbuf[1]=0;
;;;535    		comRbuf[2]=0;
;;;536    		comRbuf2[0]=0;
;;;537    		comRbuf2[1]=0;
;;;538    		comRbuf2[2]=0;
;;;539    		g_HID_sDevice.isReportReady = 1; /* To note the report data has been updated */
;;;540    		DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);	
;;;541    	}
;;;542    }
00000c  bd70              POP      {r4-r6,pc}
                  |L8.14|
00000e  4811              LDR      r0,|L8.84|
000010  3820              SUBS     r0,r0,#0x20           ;503
000012  6a44              LDR      r4,[r0,#0x24]         ;503  ; g_HID_sDevice
000014  2001              MOVS     r0,#1                 ;530
000016  7020              STRB     r0,[r4,#0]            ;530
000018  480f              LDR      r0,|L8.88|
00001a  f7fffffe          BL       atoi
00001e  4240              RSBS     r0,r0,#0              ;531
000020  7060              STRB     r0,[r4,#1]            ;531
000022  480e              LDR      r0,|L8.92|
000024  f7fffffe          BL       atoi
000028  4240              RSBS     r0,r0,#0              ;532
00002a  70a0              STRB     r0,[r4,#2]            ;532
00002c  2000              MOVS     r0,#0                 ;533
00002e  490a              LDR      r1,|L8.88|
000030  7008              STRB     r0,[r1,#0]            ;533
000032  7048              STRB     r0,[r1,#1]            ;534
000034  7088              STRB     r0,[r1,#2]            ;535
000036  4909              LDR      r1,|L8.92|
000038  7008              STRB     r0,[r1,#0]            ;536
00003a  7048              STRB     r0,[r1,#1]            ;537
00003c  7088              STRB     r0,[r1,#2]            ;538
00003e  2101              MOVS     r1,#1                 ;539
000040  4804              LDR      r0,|L8.84|
000042  7301              STRB     r1,[r0,#0xc]          ;539
000044  3820              SUBS     r0,r0,#0x20           ;540
000046  6a82              LDR      r2,[r0,#0x28]         ;540  ; g_HID_sDevice
000048  6a41              LDR      r1,[r0,#0x24]         ;540  ; g_HID_sDevice
00004a  2001              MOVS     r0,#1                 ;540
00004c  f7fffffe          BL       DrvUSB_DataIn
000050  bf00              NOP      
000052  e7db              B        |L8.12|
;;;543    
                          ENDP

                  |L8.84|
                          DCD      g_HID_sDevice+0x20
                  |L8.88|
                          DCD      comRbuf
                  |L8.92|
                          DCD      comRbuf2

                          AREA ||i.PowerDown||, CODE, READONLY, ALIGN=2

                  PowerDown PROC
;;;750    
;;;751    void PowerDown()
000000  b510              PUSH     {r4,lr}
;;;752    {
;;;753    	DBG_PRINTF("Enter power down ...\n");
000002  a02a              ADR      r0,|L9.172|
000004  f7fffffe          BL       __2printf
;;;754    
;;;755    	UNLOCKREG();
000008  2059              MOVS     r0,#0x59
00000a  492e              LDR      r1,|L9.196|
00000c  6008              STR      r0,[r1,#0]
00000e  2016              MOVS     r0,#0x16
000010  6008              STR      r0,[r1,#0]
000012  2088              MOVS     r0,#0x88
000014  6008              STR      r0,[r1,#0]
;;;756    
;;;757    	while ( IsDebugFifoEmpty() == FALSE );
000016  bf00              NOP      
                  |L9.24|
000018  f7fffffe          BL       IsDebugFifoEmpty
00001c  2800              CMP      r0,#0
00001e  d0fb              BEQ      |L9.24|
;;;758    
;;;759    	/* Wakeup Enable */
;;;760    	USBD->INTEN.WAKEUP_EN = 1;
000020  4829              LDR      r0,|L9.200|
000022  6800              LDR      r0,[r0,#0]
000024  21ff              MOVS     r1,#0xff
000026  3101              ADDS     r1,#1
000028  4388              BICS     r0,r0,r1
00002a  1840              ADDS     r0,r0,r1
00002c  4926              LDR      r1,|L9.200|
00002e  6008              STR      r0,[r1,#0]
;;;761    
;;;762    	/* Deep sleep */
;;;763    	outp32(0xE000ED10, 4);
000030  2004              MOVS     r0,#4
000032  4926              LDR      r1,|L9.204|
000034  6108              STR      r0,[r1,#0x10]
;;;764    	SYSCLK->PWRCON.PD_WAIT_CPU = 1;
000036  4826              LDR      r0,|L9.208|
000038  6800              LDR      r0,[r0,#0]
00003a  21ff              MOVS     r1,#0xff
00003c  3101              ADDS     r1,#1
00003e  4388              BICS     r0,r0,r1
000040  1840              ADDS     r0,r0,r1
000042  4923              LDR      r1,|L9.208|
000044  6008              STR      r0,[r1,#0]
;;;765    	SYSCLK->PWRCON.PWR_DOWN_EN = 1;
000046  4608              MOV      r0,r1
000048  6800              LDR      r0,[r0,#0]
00004a  2180              MOVS     r1,#0x80
00004c  4388              BICS     r0,r0,r1
00004e  3080              ADDS     r0,r0,#0x80
000050  491f              LDR      r1,|L9.208|
000052  6008              STR      r0,[r1,#0]
;;;766    	__WFI();
000054  bf30              WFI      
;;;767    	SYSCLK->PWRCON.PWR_DOWN_EN = 0;
000056  4608              MOV      r0,r1
000058  6800              LDR      r0,[r0,#0]
00005a  2180              MOVS     r1,#0x80
00005c  4388              BICS     r0,r0,r1
00005e  491c              LDR      r1,|L9.208|
000060  6008              STR      r0,[r1,#0]
;;;768    
;;;769    	if(DrvUSB_GetUsbState() & eDRVUSB_SUSPENDED)
000062  f7fffffe          BL       DrvUSB_GetUsbState
000066  2120              MOVS     r1,#0x20
000068  4208              TST      r0,r1
00006a  d01b              BEQ      |L9.164|
;;;770    	{
;;;771    		/* Note HOST to resume USB tree if it is suspended and remote wakeup enabled */
;;;772    		if(DrvUSB_IsRemoteWakeupEnabled())
00006c  f7fffffe          BL       DrvUSB_IsRemoteWakeupEnabled
000070  2800              CMP      r0,#0
000072  d017              BEQ      |L9.164|
;;;773    		{
;;;774    			/* Enable PHY before sending Resume('K') state */
;;;775    			USBD->ATTR.PHY_EN = 1;
000074  4814              LDR      r0,|L9.200|
000076  6900              LDR      r0,[r0,#0x10]
000078  2110              MOVS     r1,#0x10
00007a  4388              BICS     r0,r0,r1
00007c  3010              ADDS     r0,r0,#0x10
00007e  4912              LDR      r1,|L9.200|
000080  6108              STR      r0,[r1,#0x10]
;;;776    
;;;777    			/* Keep remote wakeup for 1 ms */
;;;778    			USBD->ATTR.RWAKEUP = 1;
000082  4608              MOV      r0,r1
000084  6900              LDR      r0,[r0,#0x10]
000086  2120              MOVS     r1,#0x20
000088  4388              BICS     r0,r0,r1
00008a  3020              ADDS     r0,r0,#0x20
00008c  490e              LDR      r1,|L9.200|
00008e  6108              STR      r0,[r1,#0x10]
;;;779    			DrvSYS_Delay(1000); /* Delay 1ms */
000090  207d              MOVS     r0,#0x7d
000092  00c0              LSLS     r0,r0,#3
000094  f7fffffe          BL       DrvSYS_Delay
;;;780    			USBD->ATTR.RWAKEUP = 0;
000098  480b              LDR      r0,|L9.200|
00009a  6900              LDR      r0,[r0,#0x10]
00009c  2120              MOVS     r1,#0x20
00009e  4388              BICS     r0,r0,r1
0000a0  4909              LDR      r1,|L9.200|
0000a2  6108              STR      r0,[r1,#0x10]
                  |L9.164|
;;;781    		}
;;;782    	}
;;;783    
;;;784    	DBG_PRINTF("device wakeup!\n");
0000a4  a00b              ADR      r0,|L9.212|
0000a6  f7fffffe          BL       __2printf
;;;785    
;;;786    }
0000aa  bd10              POP      {r4,pc}
;;;787    
                          ENDP

                  |L9.172|
0000ac  456e7465          DCB      "Enter power down ...\n",0
0000b0  7220706f
0000b4  77657220
0000b8  646f776e
0000bc  202e2e2e
0000c0  0a00    
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L9.196|
                          DCD      0x50000100
                  |L9.200|
                          DCD      0x40060000
                  |L9.204|
                          DCD      0xe000ed00
                  |L9.208|
                          DCD      0x50000200
                  |L9.212|
0000d4  64657669          DCB      "device wakeup!\n",0
0000d8  63652077
0000dc  616b6575
0000e0  70210a00

                          AREA ||i.UART_INT_HANDLE||, CODE, READONLY, ALIGN=2

                  UART_INT_HANDLE PROC
;;;788    
;;;789    void UART_INT_HANDLE(void)
000000  b538              PUSH     {r3-r5,lr}
;;;790    {
;;;791    	uint8_t bInChar[1] = {0xFF};
000002  a020              ADR      r0,|L10.132|
000004  6800              LDR      r0,[r0,#0]
000006  9000              STR      r0,[sp,#0]
;;;792    	int i=0;
000008  2400              MOVS     r4,#0
;;;793    	while(UART0->ISR.RDA_IF==1) 
00000a  e033              B        |L10.116|
                  |L10.12|
;;;794    	{
;;;795    		DrvUART_Read(UART_PORT0,bInChar,1);	
00000c  2201              MOVS     r2,#1
00000e  4669              MOV      r1,sp
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       DrvUART_Read
;;;796    		if(bInChar[0]=='s') // check if Buffer is full
000016  4668              MOV      r0,sp
000018  7800              LDRB     r0,[r0,#0]
00001a  2873              CMP      r0,#0x73
00001c  d12a              BNE      |L10.116|
;;;797    		{
;;;798    		    DrvUART_Read(UART_PORT0,bInChar,1);	
00001e  2201              MOVS     r2,#1
000020  4669              MOV      r1,sp
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       DrvUART_Read
;;;799    			while(bInChar[0]!='t')
000028  e009              B        |L10.62|
                  |L10.42|
;;;800    			{
;;;801    				comRbuf[i] = bInChar[0];
00002a  4668              MOV      r0,sp
00002c  7800              LDRB     r0,[r0,#0]
00002e  4916              LDR      r1,|L10.136|
000030  5508              STRB     r0,[r1,r4]
;;;802    				i++;	
000032  1c64              ADDS     r4,r4,#1
;;;803    				DrvUART_Read(UART_PORT0,bInChar,1);	
000034  2201              MOVS     r2,#1
000036  4669              MOV      r1,sp
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       DrvUART_Read
                  |L10.62|
00003e  4668              MOV      r0,sp                 ;799
000040  7800              LDRB     r0,[r0,#0]            ;799
000042  2874              CMP      r0,#0x74              ;799
000044  d1f1              BNE      |L10.42|
;;;804    			}
;;;805    			i=0;
000046  2400              MOVS     r4,#0
;;;806    			DrvUART_Read(UART_PORT0,bInChar,1);	
000048  2201              MOVS     r2,#1
00004a  4669              MOV      r1,sp
00004c  2000              MOVS     r0,#0
00004e  f7fffffe          BL       DrvUART_Read
;;;807    			while(bInChar[0]!='x')
000052  e009              B        |L10.104|
                  |L10.84|
;;;808    			{
;;;809    				comRbuf2[i] = bInChar[0];
000054  4668              MOV      r0,sp
000056  7800              LDRB     r0,[r0,#0]
000058  490c              LDR      r1,|L10.140|
00005a  5508              STRB     r0,[r1,r4]
;;;810    				i++;	
00005c  1c64              ADDS     r4,r4,#1
;;;811    				DrvUART_Read(UART_PORT0,bInChar,1);	
00005e  2201              MOVS     r2,#1
000060  4669              MOV      r1,sp
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       DrvUART_Read
                  |L10.104|
000068  4668              MOV      r0,sp                 ;807
00006a  7800              LDRB     r0,[r0,#0]            ;807
00006c  2878              CMP      r0,#0x78              ;807
00006e  d1f1              BNE      |L10.84|
;;;812    			}
;;;813    			i=0;
000070  2400              MOVS     r4,#0
;;;814    			break;
000072  e005              B        |L10.128|
                  |L10.116|
000074  4806              LDR      r0,|L10.144|
000076  69c0              LDR      r0,[r0,#0x1c]         ;793
000078  07c0              LSLS     r0,r0,#31             ;793
00007a  0fc0              LSRS     r0,r0,#31             ;793
00007c  2801              CMP      r0,#1                 ;793
00007e  d0c5              BEQ      |L10.12|
                  |L10.128|
000080  bf00              NOP      
;;;815    		}
;;;816    	}
;;;817    }
000082  bd38              POP      {r3-r5,pc}
;;;818    
                          ENDP

                  |L10.132|
000084  ff00              DCB      255,0
000086  00                DCB      0
000087  00                DCB      0
                  |L10.136|
                          DCD      comRbuf
                  |L10.140|
                          DCD      comRbuf2
                  |L10.144|
                          DCD      0x40050000

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_sVendorStringDesc
000000  1003              DCB      0x10,0x03
000002  004e              DCW      0x004e
000004  00550056          DCW      0x0055,0x0056
000008  004f0054          DCW      0x004f,0x0054
00000c  004f004e          DCW      0x004f,0x004e
                          %        184
0000c8  0000              DCB      0x00,0x00
                  g_sProductStringDesc
0000ca  1603              DCB      0x16,0x03
0000cc  00410052          DCW      0x0041,0x0052
0000d0  004d0020          DCW      0x004d,0x0020
0000d4  00730065          DCW      0x0073,0x0065
0000d8  00720069          DCW      0x0072,0x0069
0000dc  00650073          DCW      0x0065,0x0073
                          %        180
                  g_HID_au8MouseReportDescriptor
000194  05010902          DCB      0x05,0x01,0x09,0x02
000198  a1010901          DCB      0xa1,0x01,0x09,0x01
00019c  a1000509          DCB      0xa1,0x00,0x05,0x09
0001a0  19012903          DCB      0x19,0x01,0x29,0x03
0001a4  15002501          DCB      0x15,0x00,0x25,0x01
0001a8  95037501          DCB      0x95,0x03,0x75,0x01
0001ac  81029501          DCB      0x81,0x02,0x95,0x01
0001b0  75058101          DCB      0x75,0x05,0x81,0x01
0001b4  05010930          DCB      0x05,0x01,0x09,0x30
0001b8  09311581          DCB      0x09,0x31,0x15,0x81
0001bc  257f7508          DCB      0x25,0x7f,0x75,0x08
0001c0  95028106          DCB      0x95,0x02,0x81,0x06
0001c4  c0c00000          DCB      0xc0,0xc0,0x00,0x00
                  g_HID_u32MouseReportDescriptorSize
                          DCD      0x00000032
                  g_u32MouseReportSize
                          DCD      0x00000003
                  g_HID_au8DeviceDescriptor
0001d0  12010002          DCB      0x12,0x01,0x00,0x02
0001d4  00000008          DCB      0x00,0x00,0x00,0x08
0001d8  160442c1          DCB      0x16,0x04,0x42,0xc1
0001dc  00000102          DCB      0x00,0x00,0x01,0x02
0001e0  0001              DCB      0x00,0x01
                  g_HID_au8ConfigDescriptor
0001e2  0902              DCB      0x09,0x02
0001e4  22000101          DCB      0x22,0x00,0x01,0x01
0001e8  00a03209          DCB      0x00,0xa0,0x32,0x09
0001ec  04000001          DCB      0x04,0x00,0x00,0x01
0001f0  03010200          DCB      0x03,0x01,0x02,0x00
0001f4  09211001          DCB      0x09,0x21,0x10,0x01
0001f8  00012232          DCB      0x00,0x01,0x22,0x32
0001fc  00070581          DCB      0x00,0x07,0x05,0x81
000200  03400014          DCB      0x03,0x40,0x00,0x14
                  g_HID_au8StringLang
000204  04030904          DCB      0x04,0x03,0x09,0x04
                  g_HID_sVendorStringDesc
000208  1003              DCB      0x10,0x03
00020a  004e              DCW      0x004e
00020c  00550056          DCW      0x0055,0x0056
000210  004f0054          DCW      0x004f,0x0054
000214  004f004e          DCW      0x004f,0x004e
                          %        184
0002d0  0000              DCB      0x00,0x00
                  g_HID_sProductStringDesc
0002d2  1003              DCB      0x10,0x03
0002d4  00570050          DCW      0x0057,0x0050
0002d8  004d0020          DCW      0x004d,0x0020
0002dc  00550053          DCW      0x0055,0x0053
0002e0  0042              DCW      0x0042
0002e2  0000              DCB      0x00,0x00
                          %        184
                  g_HID_au8StringSerial
00039c  1a034200          DCB      0x1a,0x03,0x42,0x00
0003a0  30003200          DCB      0x30,0x00,0x32,0x00
0003a4  30003000          DCB      0x30,0x00,0x30,0x00
0003a8  36003000          DCB      0x36,0x00,0x30,0x00
0003ac  39003200          DCB      0x39,0x00,0x32,0x00
0003b0  31003100          DCB      0x31,0x00,0x31,0x00
0003b4  3400              DCB      0x34,0x00

                          AREA ||.data||, DATA, ALIGN=1

                  comRbuf
000000  30000000          DCB      0x30,0x00,0x00,0x00
                          %        12
                  comRbuf2
000010  30000000          DCB      0x30,0x00,0x00,0x00
                          %        12
                  TEXT1
000020  54583a20          DCB      0x54,0x58,0x3a,0x20
000024  73656e64          DCB      0x73,0x65,0x6e,0x64
000028  696e672e          DCB      0x69,0x6e,0x67,0x2e
00002c  2e2e2020          DCB      0x2e,0x2e,0x20,0x20
                  TEXT2
000030  52583a20          DCB      0x52,0x58,0x3a,0x20
000034  20202020          DCB      0x20,0x20,0x20,0x20
000038  20202000          DCB      0x20,0x20,0x20,0x00
                          DCDU     0x00000000
                  comRbytes
000040  0000              DCW      0x0000
                  comRhead
000042  0000              DCW      0x0000
                  comRtail
000044  0000              DCW      0x0000
                  ADC_result
000046  0000              DCB      0x00,0x00
                  g_au8MouseReport
000048  000000            DCB      0x00,0x00,0x00
