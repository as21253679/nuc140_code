; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\hid_api.o --depend=.\obj\hid_api.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\ -I..\..\..\..\CMSIS\CM0\CoreSupport -I..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx -I..\..\..\Include -I..\..\..\Include\Driver -I..\..\..\Include\NUC1xx-LB_002 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\hid_api.crf HID_API.c]
                          THUMB

                          AREA ||i.DrvUSB_BusResumeCallback||, CODE, READONLY, ALIGN=1

                  DrvUSB_BusResumeCallback PROC
;;;869    
;;;870    void DrvUSB_BusResumeCallback(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;871    {
000002  4605              MOV      r5,r0
;;;872    	DrvUSB_SetUsbState((E_DRVUSB_STATE)((uint32_t)DrvUSB_GetUsbState() & (uint32_t)(~eDRVUSB_SUSPENDED)));
000004  f7fffffe          BL       DrvUSB_GetUsbState
000008  2120              MOVS     r1,#0x20
00000a  4388              BICS     r0,r0,r1
00000c  4604              MOV      r4,r0
00000e  f7fffffe          BL       DrvUSB_SetUsbState
;;;873    }
000012  bd70              POP      {r4-r6,pc}
;;;874    
                          ENDP


                          AREA ||i.DrvUSB_BusSuspendCallback||, CODE, READONLY, ALIGN=1

                  DrvUSB_BusSuspendCallback PROC
;;;863    
;;;864    void DrvUSB_BusSuspendCallback(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;865    {
000002  4605              MOV      r5,r0
;;;866    	/* Note!! We should not power down or idle in Handler mode */
;;;867    	DrvUSB_SetUsbState((E_DRVUSB_STATE)((uint32_t)DrvUSB_GetUsbState() | (uint32_t)eDRVUSB_SUSPENDED));
000004  f7fffffe          BL       DrvUSB_GetUsbState
000008  2120              MOVS     r1,#0x20
00000a  4308              ORRS     r0,r0,r1
00000c  4604              MOV      r4,r0
00000e  f7fffffe          BL       DrvUSB_SetUsbState
;;;868    }
000012  bd70              POP      {r4-r6,pc}
;;;869    
                          ENDP


                          AREA ||i.HID_GetOutReportAck||, CODE, READONLY, ALIGN=1

                  HID_GetOutReportAck PROC
;;;734    Therefore, we could prepare next out report here. */
;;;735    void HID_GetOutReportAck(uint8_t *buf, uint32_t size)
000000  4770              BX       lr
;;;736    {
;;;737    
;;;738    }
;;;739    
                          ENDP


                          AREA ||i.HID_Init||, CODE, READONLY, ALIGN=2

                  HID_Init PROC
;;;462    
;;;463    void HID_Init(void)
000000  b510              PUSH     {r4,lr}
;;;464    {
;;;465    	/* Open HID to initial the descriptors and control handlers */
;;;466    	HID_Open();
000002  f7fffffe          BL       HID_Open
;;;467    
;;;468    #if(HID_FUNCTION == HID_MOUSE)
;;;469    
;;;470    	/* Set the HID report descriptor */
;;;471    	HID_SetReportDescriptor(g_HID_au8MouseReportDescriptor, g_HID_u32MouseReportDescriptorSize);
;;;472    
;;;473    	/* Set the HID report buffer */
;;;474    	HID_SetReportBuf(g_au8MouseReport, g_u32MouseReportSize);
;;;475    
;;;476    #elif(HID_FUNCTION == HID_DIGITIZER)
;;;477    	/* Set the HID report descriptor */
;;;478    	HID_SetReportDescriptor(g_HID_au8DigitizerReportDescriptor, g_HID_u32DigitizerReportDescriptorSize);
;;;479    
;;;480    	/* Set the HID report buffer */
;;;481    	HID_SetReportBuf(g_au8DigitizerReport, g_u32DigitizerReportSize);
;;;482    #else
;;;483    	/* Set the HID report descriptor */
;;;484    	HID_SetReportDescriptor(g_HID_au8KeyboardReportDescriptor, g_HID_u32KeyboardReportDescriptorSize);
000006  216e              MOVS     r1,#0x6e
000008  4803              LDR      r0,|L4.24|
00000a  f7fffffe          BL       HID_SetReportDescriptor
;;;485    
;;;486    	/* Set the HID report buffer */
;;;487    	HID_SetReportBuf(g_au8KeyboardReport, g_u32KeyboardReportSize);
00000e  2109              MOVS     r1,#9
000010  4802              LDR      r0,|L4.28|
000012  f7fffffe          BL       HID_SetReportBuf
;;;488    #endif
;;;489    
;;;490    }
000016  bd10              POP      {r4,pc}
;;;491    
                          ENDP

                  |L4.24|
                          DCD      g_HID_au8KeyboardReportDescriptor
                  |L4.28|
                          DCD      g_au8KeyboardReport

                          AREA ||i.HID_MainProcess||, CODE, READONLY, ALIGN=2

                  HID_MainProcess PROC
;;;797    
;;;798    int32_t HID_MainProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;799    {
;;;800    
;;;801    	int32_t i32Ret = 0;
000002  2500              MOVS     r5,#0
;;;802    	E_DRVUSB_STATE eUsbState;
;;;803    
;;;804    	//GPIOD->IEN = (1 << 1);
;;;805    	NVIC_EnableIRQ(GPCDE_IRQn);
000004  bf00              NOP      
000006  2005              MOVS     r0,#5
000008  2101              MOVS     r1,#1
00000a  4081              LSLS     r1,r1,r0
00000c  4819              LDR      r0,|L5.116|
00000e  6001              STR      r1,[r0,#0]
000010  bf00              NOP      
;;;806    
;;;807    	i32Ret = DrvUSB_Open((void *)DrvUSB_DispatchEvent);
000012  4819              LDR      r0,|L5.120|
000014  f7fffffe          BL       DrvUSB_Open
000018  4605              MOV      r5,r0
;;;808    	if(i32Ret != 0)
00001a  2d00              CMP      r5,#0
00001c  d001              BEQ      |L5.34|
;;;809    		return i32Ret;
00001e  4628              MOV      r0,r5
;;;810    
;;;811    	DrvUART_EnableInt(UART_PORT0, DRVUART_RDAINT, UART_INT_HANDLE);  
;;;812    
;;;813    
;;;814    
;;;815    	while(1)
;;;816    	{
;;;817    		/* Disable USB-related interrupts. */
;;;818    		_DRVUSB_ENABLE_MISC_INT(0);
;;;819    
;;;820    		/* Enable float-detection interrupt. */
;;;821    		_DRVUSB_ENABLE_FLDET_INT();
;;;822    
;;;823    		/* Start HID and install the callback functions to handle in/out report */
;;;824    		HID_Init();
;;;825    
;;;826    		/* Enable USB-related interrupts. */
;;;827    		_DRVUSB_ENABLE_MISC_INT(INTEN_WAKEUP | INTEN_WAKEUPEN | INTEN_FLDET | INTEN_USB | INTEN_BUS);
;;;828    
;;;829    		/* Enter power down to wait USB attached */
;;;830    		// PowerDown();
;;;831    
;;;832    		/* Poll and handle USB events. */
;;;833    		while(1)
;;;834    		{	
;;;835    
;;;836    			// show_string(0,10,"dx");
;;;837    			eUsbState = DrvUSB_GetUsbState();
;;;838    
;;;839    			if (eUsbState == eDRVUSB_DETACHED)
;;;840    			{	 
;;;841    				DBG_PRINTF("USB Detached!\n");
;;;842    				break;
;;;843    			}
;;;844    
;;;845    			if (eUsbState & eDRVUSB_SUSPENDED)
;;;846    			{	
;;;847    				/* Enter suspend here */
;;;848    				// PowerDown();
;;;849    			}
;;;850    
;;;851    			if (eUsbState == eDRVUSB_CONFIGURED)
;;;852    			{	 
;;;853    				/* Set HID IN report for interrupt IN transfer */
;;;854    
;;;855    				HID_SetInReport();
;;;856    			}
;;;857    		}
;;;858    
;;;859    		/* Disable USB-related interrupts. */
;;;860    		_DRVUSB_ENABLE_MISC_INT(0);
;;;861    	}
;;;862    }
000020  bd70              POP      {r4-r6,pc}
                  |L5.34|
000022  4a16              LDR      r2,|L5.124|
000024  2101              MOVS     r1,#1                 ;811
000026  2000              MOVS     r0,#0                 ;811
000028  f7fffffe          BL       DrvUART_EnableInt
00002c  e021              B        |L5.114|
                  |L5.46|
00002e  2000              MOVS     r0,#0                 ;818
000030  4913              LDR      r1,|L5.128|
000032  6008              STR      r0,[r1,#0]            ;818
000034  4608              MOV      r0,r1                 ;821
000036  6800              LDR      r0,[r0,#0]            ;821
000038  2104              MOVS     r1,#4                 ;821
00003a  4388              BICS     r0,r0,r1              ;821
00003c  1d00              ADDS     r0,r0,#4              ;821
00003e  4910              LDR      r1,|L5.128|
000040  6008              STR      r0,[r1,#0]            ;821
000042  f7fffffe          BL       HID_Init
000046  200f              MOVS     r0,#0xf               ;827
000048  490d              LDR      r1,|L5.128|
00004a  6008              STR      r0,[r1,#0]            ;827
00004c  e00c              B        |L5.104|
                  |L5.78|
00004e  f7fffffe          BL       DrvUSB_GetUsbState
000052  4604              MOV      r4,r0                 ;837
000054  2c00              CMP      r4,#0                 ;839
000056  d103              BNE      |L5.96|
000058  a00a              ADR      r0,|L5.132|
00005a  f7fffffe          BL       __2printf
00005e  e004              B        |L5.106|
                  |L5.96|
000060  2c1f              CMP      r4,#0x1f              ;851
000062  d101              BNE      |L5.104|
000064  f7fffffe          BL       HID_SetInReport
                  |L5.104|
000068  e7f1              B        |L5.78|
                  |L5.106|
00006a  bf00              NOP                            ;842
00006c  2000              MOVS     r0,#0                 ;860
00006e  4904              LDR      r1,|L5.128|
000070  6008              STR      r0,[r1,#0]            ;860
                  |L5.114|
000072  e7dc              B        |L5.46|
;;;863    
                          ENDP

                  |L5.116|
                          DCD      0xe000e100
                  |L5.120|
                          DCD      DrvUSB_DispatchEvent
                  |L5.124|
                          DCD      UART_INT_HANDLE
                  |L5.128|
                          DCD      0x40060000
                  |L5.132|
000084  55534220          DCB      "USB Detached!\n",0
000088  44657461
00008c  63686564
000090  210a00  
000093  00                DCB      0

                          AREA ||i.HID_SetFirstInReport||, CODE, READONLY, ALIGN=2

                  HID_SetFirstInReport PROC
;;;726    /* This function is used to prepare the first in report */
;;;727    void HID_SetFirstInReport(void)
000000  b510              PUSH     {r4,lr}
;;;728    {
;;;729    	DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);
000002  4803              LDR      r0,|L6.16|
000004  6a82              LDR      r2,[r0,#0x28]  ; g_HID_sDevice
000006  6a41              LDR      r1,[r0,#0x24]  ; g_HID_sDevice
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       DrvUSB_DataIn
;;;730    }
00000e  bd10              POP      {r4,pc}
;;;731    
                          ENDP

                  |L6.16|
                          DCD      g_HID_sDevice

                          AREA ||i.HID_SetFirstOutReport||, CODE, READONLY, ALIGN=1

                  HID_SetFirstOutReport PROC
;;;720    /* This function is used to prepare the first out report. */
;;;721    void HID_SetFirstOutReport(void)
000000  4770              BX       lr
;;;722    {
;;;723    
;;;724    }
;;;725    
                          ENDP


                          AREA ||i.HID_SetInReport||, CODE, READONLY, ALIGN=2

                  HID_SetInReport PROC
;;;612    
;;;613    void HID_SetInReport()
000000  b5f8              PUSH     {r3-r7,lr}
;;;614    {
;;;615    	/*  uint8_t *buf;
;;;616    	int32_t i;
;;;617    	uint32_t key = 0xF;
;;;618    	static uint32_t preKey;
;;;619    
;;;620    
;;;621    	if(g_HID_sDevice.isReportReady)
;;;622    	//    return;
;;;623    
;;;624    
;;;625    	//  If GPD1 = 0, just report it is key 'a' 
;;;626    	key = (GPIOD->PIN & (1 << 1))? 0 : 1;
;;;627    
;;;628    	buf = g_HID_sDevice.pu8Report;
;;;629    
;;;630    	if (key == 0)
;;;631    	{
;;;632    	for (i=0;i<8;i++)
;;;633    	{
;;;634    	buf[i] = 0;
;;;635    	}
;;;636    
;;;637    	if(key != preKey)
;;;638    	{
;;;639    	// Trigger to note key release 
;;;640    	g_HID_sDevice.isReportReady = 1;
;;;641    	DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);
;;;642    	}
;;;643    	}
;;;644    	else
;;;645    	{
;;;646    
;;;647    	preKey = key;
;;;648    	buf[2] = 0x04;// Key A 
;;;649    	g_HID_sDevice.isReportReady = 1;
;;;650    	DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);
;;;651    	}  															  */
;;;652    	uint8_t *buf;
;;;653    	int32_t i;
;;;654    	uint32_t key = 0xF;
000002  260f              MOVS     r6,#0xf
;;;655    	uint32_t key1 = 0xF;
000004  270f              MOVS     r7,#0xf
;;;656    	uint32_t key2 = 0xF;
000006  200f              MOVS     r0,#0xf
000008  9000              STR      r0,[sp,#0]
;;;657    
;;;658    	static uint32_t preKey;
;;;659    
;;;660    	/* To check if previous report data is processed or not */
;;;661    	if(g_HID_sDevice.isReportReady)
00000a  4824              LDR      r0,|L8.156|
00000c  7b00              LDRB     r0,[r0,#0xc]
00000e  2800              CMP      r0,#0
000010  d000              BEQ      |L8.20|
                  |L8.18|
;;;662    		return;
;;;663    	/* Update new report data */
;;;664    
;;;665    	/* If GPD2 = 0, just report it is key 'a' */
;;;666    	key = (GPIOD->PIN & (1 << 2))? 0 : 1;
;;;667    	key=1;
;;;668    	buf = g_HID_sDevice.pu8Report;
;;;669    
;;;670    	if (key == 0)
;;;671    	{
;;;672    
;;;673    		buf[0] = 0x01;	/* Report ID */ 
;;;674    
;;;675    		for (i=1;i<9;i++)
;;;676    		{
;;;677    			buf[i] = 0;										 
;;;678    		}
;;;679    
;;;680    		if((key != preKey) && (key1 != preKey) && (key2 != preKey))
;;;681    		{
;;;682    			/* Trigger to note key release */
;;;683    			g_HID_sDevice.isReportReady = 1;
;;;684    			DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);
;;;685    		}
;;;686    	}
;;;687    	else if (key == 1)
;;;688    	{	
;;;689    
;;;690    		preKey = key;
;;;691    		buf[0] = 0x01;	/* Report ID */
;;;692    		buf[3] = 0x2c;
;;;693    	/*	if(comRbuf[0]=='1') 
;;;694    			buf[3] = 0x4f; 	// Key A    2c =space      4f,50
;;;695    
;;;696    		else if(comRbuf[0]=='2') 
;;;697    		
;;;698    			buf[3] = 0x50; 
;;;699    			
;;;700    		else if(comRbuf[0]=='3') 
;;;701    			buf[3] = 0x2c; 
;;;702    		else if(comRbuf[0]=='4') 
;;;703    			buf[3] = 0x07; 
;;;704    		else
;;;705    			buf[3] = 0x00;			  */
;;;706    
;;;707    		DrvSYS_Delay(2000);	
;;;708    		g_HID_sDevice.isReportReady = 1;   
;;;709    		DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);
;;;710    
;;;711    	}  
;;;712    }
000012  bdf8              POP      {r3-r7,pc}
                  |L8.20|
000014  4822              LDR      r0,|L8.160|
000016  6900              LDR      r0,[r0,#0x10]         ;666
000018  0881              LSRS     r1,r0,#2              ;666
00001a  2001              MOVS     r0,#1                 ;666
00001c  4388              BICS     r0,r0,r1              ;666
00001e  4606              MOV      r6,r0                 ;666
000020  2601              MOVS     r6,#1                 ;667
000022  481e              LDR      r0,|L8.156|
000024  3820              SUBS     r0,r0,#0x20           ;668
000026  6a44              LDR      r4,[r0,#0x24]         ;668  ; g_HID_sDevice
000028  2e00              CMP      r6,#0                 ;670
00002a  d11f              BNE      |L8.108|
00002c  2001              MOVS     r0,#1                 ;673
00002e  7020              STRB     r0,[r4,#0]            ;673
000030  2501              MOVS     r5,#1                 ;675
000032  e002              B        |L8.58|
                  |L8.52|
000034  2000              MOVS     r0,#0                 ;677
000036  5560              STRB     r0,[r4,r5]            ;677
000038  1c6d              ADDS     r5,r5,#1              ;675
                  |L8.58|
00003a  2d09              CMP      r5,#9                 ;675
00003c  dbfa              BLT      |L8.52|
00003e  4819              LDR      r0,|L8.164|
000040  6800              LDR      r0,[r0,#0]            ;680  ; preKey
000042  4286              CMP      r6,r0                 ;680
000044  d027              BEQ      |L8.150|
000046  4817              LDR      r0,|L8.164|
000048  6800              LDR      r0,[r0,#0]            ;680  ; preKey
00004a  4287              CMP      r7,r0                 ;680
00004c  d023              BEQ      |L8.150|
00004e  4915              LDR      r1,|L8.164|
000050  9800              LDR      r0,[sp,#0]            ;680
000052  6809              LDR      r1,[r1,#0]            ;680  ; preKey
000054  4288              CMP      r0,r1                 ;680
000056  d01e              BEQ      |L8.150|
000058  2101              MOVS     r1,#1                 ;683
00005a  4810              LDR      r0,|L8.156|
00005c  7301              STRB     r1,[r0,#0xc]          ;683
00005e  3820              SUBS     r0,r0,#0x20           ;684
000060  6a82              LDR      r2,[r0,#0x28]         ;684  ; g_HID_sDevice
000062  6a41              LDR      r1,[r0,#0x24]         ;684  ; g_HID_sDevice
000064  2001              MOVS     r0,#1                 ;684
000066  f7fffffe          BL       DrvUSB_DataIn
00006a  e014              B        |L8.150|
                  |L8.108|
00006c  2e01              CMP      r6,#1                 ;687
00006e  d112              BNE      |L8.150|
000070  480c              LDR      r0,|L8.164|
000072  6006              STR      r6,[r0,#0]            ;690  ; preKey
000074  2001              MOVS     r0,#1                 ;691
000076  7020              STRB     r0,[r4,#0]            ;691
000078  202c              MOVS     r0,#0x2c              ;692
00007a  70e0              STRB     r0,[r4,#3]            ;692
00007c  207d              MOVS     r0,#0x7d              ;707
00007e  0100              LSLS     r0,r0,#4              ;707
000080  f7fffffe          BL       DrvSYS_Delay
000084  2101              MOVS     r1,#1                 ;708
000086  4805              LDR      r0,|L8.156|
000088  7301              STRB     r1,[r0,#0xc]          ;708
00008a  3820              SUBS     r0,r0,#0x20           ;709
00008c  6a82              LDR      r2,[r0,#0x28]         ;709  ; g_HID_sDevice
00008e  6a41              LDR      r1,[r0,#0x24]         ;709  ; g_HID_sDevice
000090  2001              MOVS     r0,#1                 ;709
000092  f7fffffe          BL       DrvUSB_DataIn
                  |L8.150|
000096  bf00              NOP      
000098  e7bb              B        |L8.18|
;;;713    
                          ENDP

00009a  0000              DCW      0x0000
                  |L8.156|
                          DCD      g_HID_sDevice+0x20
                  |L8.160|
                          DCD      0x500040c0
                  |L8.164|
                          DCD      preKey

                          AREA ||i.PowerDown||, CODE, READONLY, ALIGN=2

                  PowerDown PROC
;;;739    
;;;740    void PowerDown()
000000  b510              PUSH     {r4,lr}
;;;741    {
;;;742    	DBG_PRINTF("Enter power down ...\n");
000002  a02a              ADR      r0,|L9.172|
000004  f7fffffe          BL       __2printf
;;;743    
;;;744    	UNLOCKREG();
000008  2059              MOVS     r0,#0x59
00000a  492e              LDR      r1,|L9.196|
00000c  6008              STR      r0,[r1,#0]
00000e  2016              MOVS     r0,#0x16
000010  6008              STR      r0,[r1,#0]
000012  2088              MOVS     r0,#0x88
000014  6008              STR      r0,[r1,#0]
;;;745    
;;;746    	while ( IsDebugFifoEmpty() == FALSE );
000016  bf00              NOP      
                  |L9.24|
000018  f7fffffe          BL       IsDebugFifoEmpty
00001c  2800              CMP      r0,#0
00001e  d0fb              BEQ      |L9.24|
;;;747    
;;;748    	/* Wakeup Enable */
;;;749    	USBD->INTEN.WAKEUP_EN = 1;
000020  4829              LDR      r0,|L9.200|
000022  6800              LDR      r0,[r0,#0]
000024  21ff              MOVS     r1,#0xff
000026  3101              ADDS     r1,#1
000028  4388              BICS     r0,r0,r1
00002a  1840              ADDS     r0,r0,r1
00002c  4926              LDR      r1,|L9.200|
00002e  6008              STR      r0,[r1,#0]
;;;750    
;;;751    	/* Deep sleep */
;;;752    	outp32(0xE000ED10, 4);
000030  2004              MOVS     r0,#4
000032  4926              LDR      r1,|L9.204|
000034  6108              STR      r0,[r1,#0x10]
;;;753    	SYSCLK->PWRCON.PD_WAIT_CPU = 1;
000036  4826              LDR      r0,|L9.208|
000038  6800              LDR      r0,[r0,#0]
00003a  21ff              MOVS     r1,#0xff
00003c  3101              ADDS     r1,#1
00003e  4388              BICS     r0,r0,r1
000040  1840              ADDS     r0,r0,r1
000042  4923              LDR      r1,|L9.208|
000044  6008              STR      r0,[r1,#0]
;;;754    	SYSCLK->PWRCON.PWR_DOWN_EN = 1;
000046  4608              MOV      r0,r1
000048  6800              LDR      r0,[r0,#0]
00004a  2180              MOVS     r1,#0x80
00004c  4388              BICS     r0,r0,r1
00004e  3080              ADDS     r0,r0,#0x80
000050  491f              LDR      r1,|L9.208|
000052  6008              STR      r0,[r1,#0]
;;;755    	__WFI();
000054  bf30              WFI      
;;;756    	SYSCLK->PWRCON.PWR_DOWN_EN = 0;
000056  4608              MOV      r0,r1
000058  6800              LDR      r0,[r0,#0]
00005a  2180              MOVS     r1,#0x80
00005c  4388              BICS     r0,r0,r1
00005e  491c              LDR      r1,|L9.208|
000060  6008              STR      r0,[r1,#0]
;;;757    
;;;758    	if(DrvUSB_GetUsbState() & eDRVUSB_SUSPENDED)
000062  f7fffffe          BL       DrvUSB_GetUsbState
000066  2120              MOVS     r1,#0x20
000068  4208              TST      r0,r1
00006a  d01b              BEQ      |L9.164|
;;;759    	{
;;;760    		/* Note HOST to resume USB tree if it is suspended and remote wakeup enabled */
;;;761    		if(DrvUSB_IsRemoteWakeupEnabled())
00006c  f7fffffe          BL       DrvUSB_IsRemoteWakeupEnabled
000070  2800              CMP      r0,#0
000072  d017              BEQ      |L9.164|
;;;762    		{
;;;763    			/* Enable PHY before sending Resume('K') state */
;;;764    			USBD->ATTR.PHY_EN = 1;
000074  4814              LDR      r0,|L9.200|
000076  6900              LDR      r0,[r0,#0x10]
000078  2110              MOVS     r1,#0x10
00007a  4388              BICS     r0,r0,r1
00007c  3010              ADDS     r0,r0,#0x10
00007e  4912              LDR      r1,|L9.200|
000080  6108              STR      r0,[r1,#0x10]
;;;765    
;;;766    			/* Keep remote wakeup for 1 ms */
;;;767    			USBD->ATTR.RWAKEUP = 1;
000082  4608              MOV      r0,r1
000084  6900              LDR      r0,[r0,#0x10]
000086  2120              MOVS     r1,#0x20
000088  4388              BICS     r0,r0,r1
00008a  3020              ADDS     r0,r0,#0x20
00008c  490e              LDR      r1,|L9.200|
00008e  6108              STR      r0,[r1,#0x10]
;;;768    			DrvSYS_Delay(1000); /* Delay 1ms */
000090  207d              MOVS     r0,#0x7d
000092  00c0              LSLS     r0,r0,#3
000094  f7fffffe          BL       DrvSYS_Delay
;;;769    			USBD->ATTR.RWAKEUP = 0;
000098  480b              LDR      r0,|L9.200|
00009a  6900              LDR      r0,[r0,#0x10]
00009c  2120              MOVS     r1,#0x20
00009e  4388              BICS     r0,r0,r1
0000a0  4909              LDR      r1,|L9.200|
0000a2  6108              STR      r0,[r1,#0x10]
                  |L9.164|
;;;770    		}
;;;771    	}
;;;772    
;;;773    	DBG_PRINTF("device wakeup!\n");
0000a4  a00b              ADR      r0,|L9.212|
0000a6  f7fffffe          BL       __2printf
;;;774    
;;;775    }
0000aa  bd10              POP      {r4,pc}
;;;776    
                          ENDP

                  |L9.172|
0000ac  456e7465          DCB      "Enter power down ...\n",0
0000b0  7220706f
0000b4  77657220
0000b8  646f776e
0000bc  202e2e2e
0000c0  0a00    
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L9.196|
                          DCD      0x50000100
                  |L9.200|
                          DCD      0x40060000
                  |L9.204|
                          DCD      0xe000ed00
                  |L9.208|
                          DCD      0x50000200
                  |L9.212|
0000d4  64657669          DCB      "device wakeup!\n",0
0000d8  63652077
0000dc  616b6575
0000e0  70210a00

                          AREA ||i.UART_INT_HANDLE||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  UART_INT_HANDLE PROC
;;;777    
;;;778    void UART_INT_HANDLE(void)
000000  b508              PUSH     {r3,lr}
;;;779    {
;;;780    	uint8_t bInChar[1] = {0xFF};
000002  a018              ADR      r0,|L10.100|
000004  6800              LDR      r0,[r0,#0]
000006  9000              STR      r0,[sp,#0]
;;;781    
;;;782    	while(UART0->ISR.RDA_IF==1) 
000008  e024              B        |L10.84|
                  |L10.10|
;;;783    	{
;;;784    		DrvUART_Read(UART_PORT0,bInChar,1);	
00000a  2201              MOVS     r2,#1
00000c  4669              MOV      r1,sp
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       DrvUART_Read
;;;785    		if(bInChar[0]=='s') // check if Buffer is full
000014  4668              MOV      r0,sp
000016  7800              LDRB     r0,[r0,#0]
000018  2873              CMP      r0,#0x73
00001a  d11b              BNE      |L10.84|
;;;786    		{
;;;787    			DrvUART_Read(UART_PORT0,bInChar,1);	
00001c  2201              MOVS     r2,#1
00001e  4669              MOV      r1,sp
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       DrvUART_Read
;;;788    			comRbuf[0] = bInChar[0];
000026  4668              MOV      r0,sp
000028  7800              LDRB     r0,[r0,#0]
00002a  490f              LDR      r1,|L10.104|
00002c  7008              STRB     r0,[r1,#0]
;;;789    			DrvUART_Read(UART_PORT0,bInChar,1);	
00002e  2201              MOVS     r2,#1
000030  4669              MOV      r1,sp
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       DrvUART_Read
;;;790    			comRbuf[1] = bInChar[0];
000038  4668              MOV      r0,sp
00003a  7800              LDRB     r0,[r0,#0]
00003c  490a              LDR      r1,|L10.104|
00003e  7048              STRB     r0,[r1,#1]
;;;791    			sprintf(TEXT2+4,"%s",comRbuf);
000040  460a              MOV      r2,r1
000042  a10a              ADR      r1,|L10.108|
000044  480a              LDR      r0,|L10.112|
000046  f7fffffe          BL       __2sprintf
;;;792    			print_lcd(2,TEXT2);
00004a  4909              LDR      r1,|L10.112|
00004c  1f09              SUBS     r1,r1,#4
00004e  2002              MOVS     r0,#2
000050  f7fffffe          BL       print_lcd
                  |L10.84|
000054  4807              LDR      r0,|L10.116|
000056  69c0              LDR      r0,[r0,#0x1c]         ;782
000058  07c0              LSLS     r0,r0,#31             ;782
00005a  0fc0              LSRS     r0,r0,#31             ;782
00005c  2801              CMP      r0,#1                 ;782
00005e  d0d4              BEQ      |L10.10|
;;;793    		}	
;;;794    	}
;;;795    }
000060  bd08              POP      {r3,pc}
;;;796    
                          ENDP

000062  0000              DCW      0x0000
                  |L10.100|
000064  ff00              DCB      255,0
000066  00                DCB      0
000067  00                DCB      0
                  |L10.104|
                          DCD      comRbuf
                  |L10.108|
00006c  257300            DCB      "%s",0
00006f  00                DCB      0
                  |L10.112|
                          DCD      TEXT2+0x4
                  |L10.116|
                          DCD      0x40050000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_au8KeyboardReport
                          %        9

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_sVendorStringDesc
000000  1003              DCB      0x10,0x03
000002  004e              DCW      0x004e
000004  00550056          DCW      0x0055,0x0056
000008  004f0054          DCW      0x004f,0x0054
00000c  004f004e          DCW      0x004f,0x004e
                          %        184
0000c8  0000              DCB      0x00,0x00
                  g_sProductStringDesc
0000ca  1603              DCB      0x16,0x03
0000cc  00410052          DCW      0x0041,0x0052
0000d0  004d0020          DCW      0x004d,0x0020
0000d4  00730065          DCW      0x0073,0x0065
0000d8  00720069          DCW      0x0072,0x0069
0000dc  00650073          DCW      0x0065,0x0073
                          %        180
                  g_HID_au8KeyboardReportDescriptor
000194  05010906          DCB      0x05,0x01,0x09,0x06
000198  a1018501          DCB      0xa1,0x01,0x85,0x01
00019c  050719e0          DCB      0x05,0x07,0x19,0xe0
0001a0  29e71500          DCB      0x29,0xe7,0x15,0x00
0001a4  25017501          DCB      0x25,0x01,0x75,0x01
0001a8  95088102          DCB      0x95,0x08,0x81,0x02
0001ac  95017508          DCB      0x95,0x01,0x75,0x08
0001b0  81019505          DCB      0x81,0x01,0x95,0x05
0001b4  75010508          DCB      0x75,0x01,0x05,0x08
0001b8  19012905          DCB      0x19,0x01,0x29,0x05
0001bc  91029501          DCB      0x91,0x02,0x95,0x01
0001c0  75039101          DCB      0x75,0x03,0x91,0x01
0001c4  95067508          DCB      0x95,0x06,0x75,0x08
0001c8  15002565          DCB      0x15,0x00,0x25,0x65
0001cc  05071900          DCB      0x05,0x07,0x19,0x00
0001d0  29658100          DCB      0x29,0x65,0x81,0x00
0001d4  c0050c09          DCB      0xc0,0x05,0x0c,0x09
0001d8  01a10185          DCB      0x01,0xa1,0x01,0x85
0001dc  02150025          DCB      0x02,0x15,0x00,0x25
0001e0  0109e209          DCB      0x01,0x09,0xe2,0x09
0001e4  e909ea09          DCB      0xe9,0x09,0xea,0x09
0001e8  6f097075          DCB      0x6f,0x09,0x70,0x75
0001ec  01950581          DCB      0x01,0x95,0x05,0x81
0001f0  02050109          DCB      0x02,0x05,0x01,0x09
0001f4  82750195          DCB      0x82,0x75,0x01,0x95
0001f8  01810275          DCB      0x01,0x81,0x02,0x75
0001fc  01950281          DCB      0x01,0x95,0x02,0x81
000200  03c00000          DCB      0x03,0xc0,0x00,0x00
                  g_HID_u32KeyboardReportDescriptorSize
                          DCD      0x0000006e
                  g_u32KeyboardReportSize
                          DCD      0x00000009
                  g_HID_au8DeviceDescriptor
00020c  12010002          DCB      0x12,0x01,0x00,0x02
000210  00000008          DCB      0x00,0x00,0x00,0x08
000214  160441c1          DCB      0x16,0x04,0x41,0xc1
000218  00000102          DCB      0x00,0x00,0x01,0x02
00021c  0001              DCB      0x00,0x01
                  g_HID_au8ConfigDescriptor
00021e  0902              DCB      0x09,0x02
000220  22000101          DCB      0x22,0x00,0x01,0x01
000224  00a03209          DCB      0x00,0xa0,0x32,0x09
000228  04000001          DCB      0x04,0x00,0x00,0x01
00022c  03010100          DCB      0x03,0x01,0x01,0x00
000230  09211001          DCB      0x09,0x21,0x10,0x01
000234  0001226e          DCB      0x00,0x01,0x22,0x6e
000238  00070581          DCB      0x00,0x07,0x05,0x81
00023c  03400014          DCB      0x03,0x40,0x00,0x14
                  g_HID_au8StringLang
000240  04030904          DCB      0x04,0x03,0x09,0x04
                  g_HID_sVendorStringDesc
000244  1003              DCB      0x10,0x03
000246  004e              DCW      0x004e
000248  00550056          DCW      0x0055,0x0056
00024c  004f0054          DCW      0x004f,0x0054
000250  004f004e          DCW      0x004f,0x004e
                          %        184
00030c  0000              DCB      0x00,0x00
                  g_HID_sProductStringDesc
00030e  1003              DCB      0x10,0x03
000310  00570050          DCW      0x0057,0x0050
000314  004d0020          DCW      0x004d,0x0020
000318  00550053          DCW      0x0055,0x0053
00031c  0042              DCW      0x0042
00031e  0000              DCB      0x00,0x00
                          %        184
                  g_HID_au8StringSerial
0003d8  1a034200          DCB      0x1a,0x03,0x42,0x00
0003dc  30003200          DCB      0x30,0x00,0x32,0x00
0003e0  30003000          DCB      0x30,0x00,0x30,0x00
0003e4  36003000          DCB      0x36,0x00,0x30,0x00
0003e8  39003200          DCB      0x39,0x00,0x32,0x00
0003ec  31003100          DCB      0x31,0x00,0x31,0x00
0003f0  3400              DCB      0x34,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  comRbuf
000000  30000000          DCB      0x30,0x00,0x00,0x00
                          %        12
                  TEXT1
000010  54583a20          DCB      0x54,0x58,0x3a,0x20
000014  73656e64          DCB      0x73,0x65,0x6e,0x64
000018  696e672e          DCB      0x69,0x6e,0x67,0x2e
00001c  2e2e2020          DCB      0x2e,0x2e,0x20,0x20
                  TEXT2
000020  52583a20          DCB      0x52,0x58,0x3a,0x20
000024  20202020          DCB      0x20,0x20,0x20,0x20
000028  20202000          DCB      0x20,0x20,0x20,0x00
                          DCD      0x00000000
                  comRbytes
000030  0000              DCW      0x0000
                  comRhead
000032  0000              DCW      0x0000
                  comRtail
000034  0000              DCW      0x0000
000036  0000              DCB      0x00,0x00
                  preKey
                          DCD      0x00000000
                  ADC_result
00003c  0000              DCB      0x00,0x00
