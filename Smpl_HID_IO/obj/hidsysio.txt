; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\hidsysio.o --depend=.\obj\hidsysio.d --feedback=.\obj\Smpl_HID_IO.fed --cpu=Cortex-M0 --apcs=interwork -O0 -I.\ -I..\..\..\..\CMSIS\CM0\CoreSupport -I..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx -I..\..\..\Include -I..\..\..\Include\Driver -I..\..\..\Include\NUC1xx-LB_002 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\obj\hidsysio.crf HIDSysIO.c]
                          THUMB

                          AREA ||i.HID_Close||, CODE, READONLY, ALIGN=1

                  HID_Close PROC
;;;145    
;;;146    void HID_Close(void)
000000  4770              BX       lr
;;;147    {
;;;148    }
;;;149    
                          ENDP


                          AREA ||i.HID_CtrlGetDescriptorIn||, CODE, READONLY, ALIGN=2

                  HID_CtrlGetDescriptorIn PROC
;;;461    
;;;462    void HID_CtrlGetDescriptorIn(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;463    {
000002  4605              MOV      r5,r0
;;;464        uint32_t u32Len;
;;;465    
;;;466    
;;;467        DBG_PRINTF(" >>> 0x%08x %d size.\n", gpu8UsbBuf, gu32BytesInUsbBuf);
;;;468    	
;;;469        if(gpu8UsbBuf)
000004  481f              LDR      r0,|L2.132|
000006  6800              LDR      r0,[r0,#0]  ; gpu8UsbBuf
000008  2800              CMP      r0,#0
00000a  d036              BEQ      |L2.122|
;;;470        {
;;;471    
;;;472            if(gu32BytesInUsbBuf == 0)
00000c  481e              LDR      r0,|L2.136|
00000e  6800              LDR      r0,[r0,#0]  ; gu32BytesInUsbBuf
000010  2800              CMP      r0,#0
000012  d109              BNE      |L2.40|
;;;473            {
;;;474                /* Zero packet */
;;;475        		DrvUSB_DataIn(0, gpu8UsbBuf, 0);
000014  2200              MOVS     r2,#0
000016  481b              LDR      r0,|L2.132|
000018  6801              LDR      r1,[r0,#0]  ; gpu8UsbBuf
00001a  4610              MOV      r0,r2
00001c  f7fffffe          BL       DrvUSB_DataIn
;;;476        		gpu8UsbBuf = 0;
000020  2000              MOVS     r0,#0
000022  4918              LDR      r1,|L2.132|
000024  6008              STR      r0,[r1,#0]  ; gpu8UsbBuf
000026  e02b              B        |L2.128|
                  |L2.40|
;;;477            }
;;;478            else
;;;479            {
;;;480                u32Len = Minimum(gu32BytesInUsbBuf, HID_MAX_PACKET_SIZE_EP0);
000028  4817              LDR      r0,|L2.136|
00002a  6800              LDR      r0,[r0,#0]  ; gu32BytesInUsbBuf
00002c  2840              CMP      r0,#0x40
00002e  d202              BCS      |L2.54|
000030  4815              LDR      r0,|L2.136|
000032  6800              LDR      r0,[r0,#0]  ; gu32BytesInUsbBuf
000034  e000              B        |L2.56|
                  |L2.54|
000036  2040              MOVS     r0,#0x40
                  |L2.56|
000038  4604              MOV      r4,r0
;;;481        		DrvUSB_DataIn(0, gpu8UsbBuf, u32Len);
00003a  4622              MOV      r2,r4
00003c  4811              LDR      r0,|L2.132|
00003e  6801              LDR      r1,[r0,#0]  ; gpu8UsbBuf
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       DrvUSB_DataIn
;;;482        		gpu8UsbBuf += u32Len;
000046  480f              LDR      r0,|L2.132|
000048  6800              LDR      r0,[r0,#0]  ; gpu8UsbBuf
00004a  1900              ADDS     r0,r0,r4
00004c  490d              LDR      r1,|L2.132|
00004e  6008              STR      r0,[r1,#0]  ; gpu8UsbBuf
;;;483        		gu32BytesInUsbBuf -= u32Len;
000050  480d              LDR      r0,|L2.136|
000052  6800              LDR      r0,[r0,#0]  ; gu32BytesInUsbBuf
000054  1b00              SUBS     r0,r0,r4
000056  490c              LDR      r1,|L2.136|
000058  6008              STR      r0,[r1,#0]  ; gu32BytesInUsbBuf
;;;484        		
;;;485        		if(gu32BytesInUsbBuf == 0)
00005a  4608              MOV      r0,r1
00005c  6800              LDR      r0,[r0,#0]  ; gu32BytesInUsbBuf
00005e  2800              CMP      r0,#0
000060  d10e              BNE      |L2.128|
;;;486        		{
;;;487                    if(u32Len < HID_MAX_PACKET_SIZE_EP0)
000062  2c40              CMP      r4,#0x40
000064  d202              BCS      |L2.108|
;;;488                    {
;;;489                        /* This should be last IN packet due to it is less than UAC_MAX_PACKET_SIZE_EP0 */
;;;490                        gpu8UsbBuf = 0;
000066  4907              LDR      r1,|L2.132|
000068  6008              STR      r0,[r1,#0]  ; gpu8UsbBuf
00006a  e009              B        |L2.128|
                  |L2.108|
;;;491                    }
;;;492                    else
;;;493                    {
;;;494                        if(!gIsOverRequest)
00006c  4807              LDR      r0,|L2.140|
00006e  7800              LDRB     r0,[r0,#0]  ; gIsOverRequest
000070  2800              CMP      r0,#0
000072  d105              BNE      |L2.128|
;;;495                        {
;;;496        		            /* This should be the last IN packet because there is no more data to 
;;;497                               transfer and it is not over request transfer */
;;;498                            gpu8UsbBuf = 0;
000074  4903              LDR      r1,|L2.132|
000076  6008              STR      r0,[r1,#0]  ; gpu8UsbBuf
000078  e002              B        |L2.128|
                  |L2.122|
;;;499                        }
;;;500                     }
;;;501                }
;;;502        		
;;;503            }
;;;504        }
;;;505        else
;;;506        {
;;;507      	    /* The EP id 1 should always be used as control (OUT) endpoint */
;;;508    		_DRVUSB_TRIG_EP(1,0x00);
00007a  2000              MOVS     r0,#0
00007c  4904              LDR      r1,|L2.144|
00007e  6348              STR      r0,[r1,#0x34]
                  |L2.128|
;;;509        }
;;;510    }
000080  bd70              POP      {r4-r6,pc}
;;;511    
                          ENDP

000082  0000              DCW      0x0000
                  |L2.132|
                          DCD      gpu8UsbBuf
                  |L2.136|
                          DCD      gu32BytesInUsbBuf
                  |L2.140|
                          DCD      gIsOverRequest
                  |L2.144|
                          DCD      0x40060000

                          AREA ||i.HID_CtrlGetDescriptorOut||, CODE, READONLY, ALIGN=2

                  HID_CtrlGetDescriptorOut PROC
;;;454    
;;;455    void HID_CtrlGetDescriptorOut(void * pVoid)
000000  2100              MOVS     r1,#0
;;;456    {
;;;457        gu32BytesInUsbBuf = 0;
000002  4a03              LDR      r2,|L3.16|
000004  6011              STR      r1,[r2,#0]  ; gu32BytesInUsbBuf
;;;458        gpu8UsbBuf = 0;
000006  4a03              LDR      r2,|L3.20|
000008  6011              STR      r1,[r2,#0]  ; gpu8UsbBuf
;;;459        gIsOverRequest = 0;
00000a  4a03              LDR      r2,|L3.24|
00000c  7011              STRB     r1,[r2,#0]
;;;460    }
00000e  4770              BX       lr
;;;461    
                          ENDP

                  |L3.16|
                          DCD      gu32BytesInUsbBuf
                  |L3.20|
                          DCD      gpu8UsbBuf
                  |L3.24|
                          DCD      gIsOverRequest

                          AREA ||i.HID_CtrlSetupGetDescriptor||, CODE, READONLY, ALIGN=2

                  HID_CtrlSetupGetDescriptor PROC
;;;528    /*************************************************************************/
;;;529    void HID_CtrlSetupGetDescriptor(void * pVoid)
000000  b5f8              PUSH     {r3-r7,lr}
;;;530    {
000002  4605              MOV      r5,r0
;;;531    	S_HID_DEVICE *psDevice = (S_HID_DEVICE *) pVoid;
000004  462f              MOV      r7,r5
;;;532    	S_DRVUSB_DEVICE *pUsbDevice = (S_DRVUSB_DEVICE *)psDevice->device;
000006  6a7c              LDR      r4,[r7,#0x24]
;;;533    	uint16_t u16Len;
;;;534    
;;;535    	u16Len = 0;
000008  2600              MOVS     r6,#0
;;;536    	u16Len = pUsbDevice->au8Setup[7];
00000a  2093              MOVS     r0,#0x93
00000c  5d06              LDRB     r6,[r0,r4]
;;;537    	u16Len <<= 8;
00000e  0236              LSLS     r6,r6,#8
;;;538    	u16Len += pUsbDevice->au8Setup[6];
000010  2092              MOVS     r0,#0x92
000012  5d00              LDRB     r0,[r0,r4]
000014  1980              ADDS     r0,r0,r6
000016  b286              UXTH     r6,r0
;;;539    	
;;;540    	gIsOverRequest = 0;
000018  2000              MOVS     r0,#0
00001a  4936              LDR      r1,|L4.244|
00001c  7008              STRB     r0,[r1,#0]
;;;541    	gu32BytesInUsbBuf = 0;
00001e  4936              LDR      r1,|L4.248|
000020  6008              STR      r0,[r1,#0]  ; gu32BytesInUsbBuf
;;;542    	gpu8UsbBuf = 0;
000022  4936              LDR      r1,|L4.252|
000024  6008              STR      r0,[r1,#0]  ; gpu8UsbBuf
;;;543    	switch (pUsbDevice->au8Setup[3])
000026  208f              MOVS     r0,#0x8f
000028  5d00              LDRB     r0,[r0,r4]
00002a  2803              CMP      r0,#3
00002c  d02e              BEQ      |L4.140|
00002e  dc04              BGT      |L4.58|
000030  2801              CMP      r0,#1
000032  d007              BEQ      |L4.68|
000034  2802              CMP      r0,#2
000036  d157              BNE      |L4.232|
000038  e00f              B        |L4.90|
                  |L4.58|
00003a  2821              CMP      r0,#0x21
00003c  d016              BEQ      |L4.108|
00003e  2822              CMP      r0,#0x22
000040  d152              BNE      |L4.232|
000042  e01b              B        |L4.124|
                  |L4.68|
;;;544    	{
;;;545    		// Get Device Descriptor
;;;546    	case DESC_DEVICE:
;;;547    	{
;;;548            HID_PrepareDescriptors(g_HID_sDevice.au8DeviceDescriptor, LEN_DEVICE, u16Len, HID_MAX_PACKET_SIZE_EP0);
000044  492e              LDR      r1,|L4.256|
000046  2340              MOVS     r3,#0x40
000048  4632              MOV      r2,r6
00004a  6808              LDR      r0,[r1,#0]  ; g_HID_sDevice
00004c  2112              MOVS     r1,#0x12
00004e  f7fffffe          BL       HID_PrepareDescriptors
;;;549    
;;;550    	    /* Prepare the OUT to avoid HOST stop data phase without all data transfered. */
;;;551    		_DRVUSB_TRIG_EP(1,0x00);
000052  2000              MOVS     r0,#0
000054  492b              LDR      r1,|L4.260|
000056  6348              STR      r0,[r1,#0x34]
;;;552    
;;;553    		break;
000058  e049              B        |L4.238|
                  |L4.90|
;;;554    	}
;;;555    
;;;556    	// Get Configuration Descriptor
;;;557    	case DESC_CONFIG:
;;;558    	{	
;;;559            HID_PrepareDescriptors(g_HID_sDevice.au8ConfigDescriptor, gau8ConfigDescriptor[2], u16Len, HID_MAX_PACKET_SIZE_EP0);
00005a  4a2b              LDR      r2,|L4.264|
00005c  7891              LDRB     r1,[r2,#2]  ; gau8ConfigDescriptor
00005e  4a28              LDR      r2,|L4.256|
000060  2340              MOVS     r3,#0x40
000062  6850              LDR      r0,[r2,#4]  ; g_HID_sDevice
000064  4632              MOV      r2,r6
000066  f7fffffe          BL       HID_PrepareDescriptors
;;;560    		break;
00006a  e040              B        |L4.238|
                  |L4.108|
;;;561        }
;;;562    		// Get HID Descriptor
;;;563    	case DESC_HID:
;;;564        {
;;;565            HID_PrepareDescriptors(g_HID_sDevice.pu8HIDDescriptor, LEN_HID, u16Len, HID_MAX_PACKET_SIZE_EP0);
00006c  4924              LDR      r1,|L4.256|
00006e  2340              MOVS     r3,#0x40
000070  4632              MOV      r2,r6
000072  6948              LDR      r0,[r1,#0x14]  ; g_HID_sDevice
000074  2109              MOVS     r1,#9
000076  f7fffffe          BL       HID_PrepareDescriptors
;;;566    		break;
00007a  e038              B        |L4.238|
                  |L4.124|
;;;567        }
;;;568    		// Get Report Descriptor
;;;569    	case DESC_HID_RPT:
;;;570    	{
;;;571            HID_PrepareDescriptors(g_HID_sDevice.pu8ReportDescriptor, g_HID_sDevice.u32ReportDescriptorSize, u16Len, HID_MAX_PACKET_SIZE_EP0);
00007c  4a20              LDR      r2,|L4.256|
00007e  6911              LDR      r1,[r2,#0x10]  ; g_HID_sDevice
000080  2340              MOVS     r3,#0x40
000082  68d0              LDR      r0,[r2,#0xc]  ; g_HID_sDevice
000084  4632              MOV      r2,r6
000086  f7fffffe          BL       HID_PrepareDescriptors
;;;572    		break;
00008a  e030              B        |L4.238|
                  |L4.140|
;;;573        }
;;;574    		// Get String Descriptor
;;;575    	case DESC_STRING:
;;;576    	{
;;;577    		// Get Language
;;;578    		if (pUsbDevice->au8Setup[2] == 0)
00008c  208e              MOVS     r0,#0x8e
00008e  5d00              LDRB     r0,[r0,r4]
000090  2800              CMP      r0,#0
000092  d106              BNE      |L4.162|
;;;579    		{
;;;580                HID_PrepareDescriptors(gau8StringLang, 4, u16Len, HID_MAX_PACKET_SIZE_EP0);
000094  2340              MOVS     r3,#0x40
000096  4632              MOV      r2,r6
000098  2104              MOVS     r1,#4
00009a  481c              LDR      r0,|L4.268|
00009c  f7fffffe          BL       HID_PrepareDescriptors
0000a0  e021              B        |L4.230|
                  |L4.162|
;;;581    		}
;;;582    		else
;;;583    		{
;;;584    			// Get String Descriptor
;;;585    			switch (pUsbDevice->au8Setup[2])
0000a2  208e              MOVS     r0,#0x8e
0000a4  5d00              LDRB     r0,[r0,r4]
0000a6  2801              CMP      r0,#1
0000a8  d004              BEQ      |L4.180|
0000aa  2802              CMP      r0,#2
0000ac  d009              BEQ      |L4.194|
0000ae  2803              CMP      r0,#3
0000b0  d115              BNE      |L4.222|
0000b2  e00d              B        |L4.208|
                  |L4.180|
;;;586    			{
;;;587    			case 1:
;;;588                    HID_PrepareDescriptors((const uint8_t *)gau8VendorStringDescriptor, gau8VendorStringDescriptor[0], u16Len, HID_MAX_PACKET_SIZE_EP0);
0000b4  4816              LDR      r0,|L4.272|
0000b6  7801              LDRB     r1,[r0,#0]  ; gau8VendorStringDescriptor
0000b8  2340              MOVS     r3,#0x40
0000ba  4632              MOV      r2,r6
0000bc  f7fffffe          BL       HID_PrepareDescriptors
;;;589    				break;
0000c0  e010              B        |L4.228|
                  |L4.194|
;;;590    
;;;591    			case 2:
;;;592                    HID_PrepareDescriptors((const uint8_t *)gau8ProductStringDescriptor, gau8ProductStringDescriptor[0], u16Len, HID_MAX_PACKET_SIZE_EP0);
0000c2  4814              LDR      r0,|L4.276|
0000c4  7801              LDRB     r1,[r0,#0]  ; gau8ProductStringDescriptor
0000c6  2340              MOVS     r3,#0x40
0000c8  4632              MOV      r2,r6
0000ca  f7fffffe          BL       HID_PrepareDescriptors
;;;593                   
;;;594     				break;
0000ce  e009              B        |L4.228|
                  |L4.208|
;;;595    
;;;596    			case 3:
;;;597                    HID_PrepareDescriptors(gau8StringSerial, gau8StringSerial[0], u16Len, HID_MAX_PACKET_SIZE_EP0);
0000d0  4811              LDR      r0,|L4.280|
0000d2  7801              LDRB     r1,[r0,#0]  ; gau8StringSerial
0000d4  2340              MOVS     r3,#0x40
0000d6  4632              MOV      r2,r6
0000d8  f7fffffe          BL       HID_PrepareDescriptors
;;;598    				break;
0000dc  e002              B        |L4.228|
                  |L4.222|
;;;599    
;;;600    			default:
;;;601    				/* Not support. Reply STALL. */
;;;602    				DrvUSB_ClrCtrlReadyAndTrigStall();
0000de  f7fffffe          BL       DrvUSB_ClrCtrlReadyAndTrigStall
0000e2  bf00              NOP                            ;585
                  |L4.228|
0000e4  bf00              NOP                            ;589
                  |L4.230|
;;;603    			}
;;;604    		}
;;;605    
;;;606    		break;
0000e6  e002              B        |L4.238|
                  |L4.232|
;;;607    	}
;;;608    	default:
;;;609    		/* Not support. Reply STALL. */
;;;610    		DrvUSB_ClrCtrlReadyAndTrigStall();
0000e8  f7fffffe          BL       DrvUSB_ClrCtrlReadyAndTrigStall
0000ec  bf00              NOP                            ;543
                  |L4.238|
0000ee  bf00              NOP                            ;553
;;;611    	}
;;;612    }
0000f0  bdf8              POP      {r3-r7,pc}
;;;613    
                          ENDP

0000f2  0000              DCW      0x0000
                  |L4.244|
                          DCD      gIsOverRequest
                  |L4.248|
                          DCD      gu32BytesInUsbBuf
                  |L4.252|
                          DCD      gpu8UsbBuf
                  |L4.256|
                          DCD      g_HID_sDevice
                  |L4.260|
                          DCD      0x40060000
                  |L4.264|
                          DCD      gau8ConfigDescriptor
                  |L4.268|
                          DCD      gau8StringLang
                  |L4.272|
                          DCD      gau8VendorStringDescriptor
                  |L4.276|
                          DCD      gau8ProductStringDescriptor
                  |L4.280|
                          DCD      gau8StringSerial

                          AREA ||i.HID_CtrlSetupGetReport||, CODE, READONLY, ALIGN=2

                  HID_CtrlSetupGetReport PROC
;;;293    
;;;294    void HID_CtrlSetupGetReport(void * pVoid)
000000  b538              PUSH     {r3-r5,lr}
;;;295    {
000002  4604              MOV      r4,r0
;;;296        S_DRVUSB_DEVICE *psDevice = (S_DRVUSB_DEVICE *)((S_HID_DEVICE *)pVoid)->device;
000004  6a65              LDR      r5,[r4,#0x24]
;;;297        
;;;298    	DBG_PRINTF("HID - Get Report");
;;;299        if(psDevice->au8Setup[3] == 3)
000006  208f              MOVS     r0,#0x8f
000008  5d40              LDRB     r0,[r0,r5]
00000a  2803              CMP      r0,#3
00000c  d10d              BNE      |L5.42|
;;;300        {
;;;301    		/* Request Type = Feature */
;;;302            const uint8_t au8Data[2] = {0x01, 0x02};
00000e  a008              ADR      r0,|L5.48|
000010  6800              LDR      r0,[r0,#0]
000012  9000              STR      r0,[sp,#0]
;;;303    		
;;;304    		gpu8UsbBuf = au8Data;
000014  4668              MOV      r0,sp
000016  4907              LDR      r1,|L5.52|
000018  6008              STR      r0,[r1,#0]  ; gpu8UsbBuf
;;;305    		gu32BytesInUsbBuf = 0;
00001a  2000              MOVS     r0,#0
00001c  4906              LDR      r1,|L5.56|
00001e  6008              STR      r0,[r1,#0]  ; gu32BytesInUsbBuf
;;;306    		DrvUSB_DataIn(0, au8Data, 2);
000020  2202              MOVS     r2,#2
000022  4669              MOV      r1,sp
000024  f7fffffe          BL       DrvUSB_DataIn
;;;307        }    
000028  e001              B        |L5.46|
                  |L5.42|
;;;308    	else
;;;309    	{
;;;310            DBG_PRINTF(" - Unknown\n");
;;;311    		_HID_CLR_CTRL_READY_AND_TRIG_STALL();
00002a  f7fffffe          BL       _HID_CLR_CTRL_READY_AND_TRIG_STALL
                  |L5.46|
;;;312    	}
;;;313     }
00002e  bd38              POP      {r3-r5,pc}
;;;314    
                          ENDP

                  |L5.48|
000030  010200            DCB      1,2,0
000033  00                DCB      0
                  |L5.52|
                          DCD      gpu8UsbBuf
                  |L5.56|
                          DCD      gu32BytesInUsbBuf

                          AREA ||i.HID_CtrlSetupSetIdle||, CODE, READONLY, ALIGN=2

                  HID_CtrlSetupSetIdle PROC
;;;387    /*************************************************************************/
;;;388    void HID_CtrlSetupSetIdle(void * pVoid)
000000  4904              LDR      r1,|L6.20|
;;;389    {
;;;390        
;;;391    	_DRVUSB_SET_EP_TOG_BIT(0,FALSE);
000002  6a89              LDR      r1,[r1,#0x28]
000004  2280              MOVS     r2,#0x80
000006  4311              ORRS     r1,r1,r2
000008  4a02              LDR      r2,|L6.20|
00000a  6291              STR      r1,[r2,#0x28]
;;;392    	_DRVUSB_TRIG_EP(0,0x00);
00000c  2100              MOVS     r1,#0
00000e  6251              STR      r1,[r2,#0x24]
;;;393    
;;;394    
;;;395        DBG_PRINTF("Set idle\n");
;;;396    }
000010  4770              BX       lr
;;;397    
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40060000

                          AREA ||i.HID_CtrlSetupSetProtocol||, CODE, READONLY, ALIGN=2

                  HID_CtrlSetupSetProtocol PROC
;;;414    /*************************************************************************/
;;;415    void HID_CtrlSetupSetProtocol(void * pVoid)
000000  4904              LDR      r1,|L7.20|
;;;416    {
;;;417    
;;;418    	_DRVUSB_SET_EP_TOG_BIT(0,FALSE);
000002  6a89              LDR      r1,[r1,#0x28]
000004  2280              MOVS     r2,#0x80
000006  4311              ORRS     r1,r1,r2
000008  4a02              LDR      r2,|L7.20|
00000a  6291              STR      r1,[r2,#0x28]
;;;419    	_DRVUSB_TRIG_EP(0,0x00);
00000c  2100              MOVS     r1,#0
00000e  6251              STR      r1,[r2,#0x24]
;;;420    
;;;421        DBG_PRINTF("Set protocol");
;;;422    
;;;423    }
000010  4770              BX       lr
;;;424    
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40060000

                          AREA ||i.HID_CtrlSetupSetReport||, CODE, READONLY, ALIGN=1

                  HID_CtrlSetupSetReport PROC
;;;333    //
;;;334    void HID_CtrlSetupSetReport(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;335    {
000002  4605              MOV      r5,r0
;;;336     	S_DRVUSB_DEVICE *psDevice = (S_DRVUSB_DEVICE *)((S_HID_DEVICE *)pVoid)->device;
000004  6a6c              LDR      r4,[r5,#0x24]
;;;337    
;;;338        DBG_PRINTF("HID - Set Report");
;;;339    	if(psDevice->au8Setup[3] == HID_RPT_TYPE_INPUT)
000006  208f              MOVS     r0,#0x8f
000008  5d00              LDRB     r0,[r0,r4]
00000a  2801              CMP      r0,#1
00000c  d00e              BEQ      |L8.44|
;;;340    	{
;;;341            /* Report Type = input */
;;;342    //		_DRVUSB_SET_EP_TOG_BIT(1,FALSE);
;;;343    //		_DRVUSB_TRIG_EP(1, 0x00);
;;;344            DBG_PRINTF(" - Input\n");
;;;345    	}
;;;346    	else if (psDevice->au8Setup[3] == HID_RPT_TYPE_OUTPUT)
00000e  208f              MOVS     r0,#0x8f
000010  5d00              LDRB     r0,[r0,r4]
000012  2802              CMP      r0,#2
000014  d00a              BEQ      |L8.44|
;;;347    	{
;;;348    		/* Report Type = Output */
;;;349    //		_DRVUSB_SET_EP_TOG_BIT(1,FALSE);
;;;350    //		_DRVUSB_TRIG_EP(1,0x00);
;;;351            DBG_PRINTF(" - Output\n");
;;;352    	}
;;;353    	else if (psDevice->au8Setup[3] == HID_RPT_TYPE_FEATURE)
000016  208f              MOVS     r0,#0x8f
000018  5d00              LDRB     r0,[r0,r4]
00001a  2803              CMP      r0,#3
00001c  d104              BNE      |L8.40|
;;;354    	{
;;;355            /* Request Type = Feature */
;;;356    
;;;357            DrvUSB_DataOutTrigger(CTRL_EP_NUM, HID_MAX_PACKET_SIZE_EP0);
00001e  2140              MOVS     r1,#0x40
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       DrvUSB_DataOutTrigger
000026  e001              B        |L8.44|
                  |L8.40|
;;;358    
;;;359            DBG_PRINTF(" - Feature\n");
;;;360    	}
;;;361    	else
;;;362    	{
;;;363    		// Not support. Reply STALL.
;;;364            DBG_PRINTF(" - Unknown\n");
;;;365    
;;;366    		_HID_CLR_CTRL_READY_AND_TRIG_STALL();
000028  f7fffffe          BL       _HID_CLR_CTRL_READY_AND_TRIG_STALL
                  |L8.44|
;;;367    	}
;;;368        DBG_PRINTF("\n");
;;;369    }												
00002c  bd70              POP      {r4-r6,pc}
;;;370    
                          ENDP


                          AREA ||i.HID_GetVersion||, CODE, READONLY, ALIGN=2

                  HID_GetVersion PROC
;;;99     
;;;100    uint32_t HID_GetVersion(void)
000000  4800              LDR      r0,|L9.4|
;;;101    {
;;;102    	return HID_VERSION_NUM;
;;;103    }
000002  4770              BX       lr
;;;104    
                          ENDP

                  |L9.4|
                          DCD      0x00010001

                          AREA ||i.HID_IntInCallback||, CODE, READONLY, ALIGN=2

                  HID_IntInCallback PROC
;;;182    /*************************************************************************/
;;;183    void HID_IntInCallback(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;184    {
000002  4605              MOV      r5,r0
;;;185        S_HID_DEVICE* psDevice = (S_HID_DEVICE*) pVoid;
000004  462c              MOV      r4,r5
;;;186    
;;;187        if ((uint32_t)pfHID_GetInReport)
000006  4807              LDR      r0,|L10.36|
000008  6800              LDR      r0,[r0,#0]  ; pfHID_GetInReport
00000a  2800              CMP      r0,#0
00000c  d003              BEQ      |L10.22|
;;;188            pfHID_GetInReport(psDevice->pu8Report);
00000e  4905              LDR      r1,|L10.36|
000010  69a0              LDR      r0,[r4,#0x18]
000012  6809              LDR      r1,[r1,#0]  ; pfHID_GetInReport
000014  4788              BLX      r1
                  |L10.22|
;;;189    
;;;190        DrvUSB_DataIn(HID_IN_EP_NUM, psDevice->pu8Report, psDevice->u32ReportSize);
000016  2001              MOVS     r0,#1
000018  69e2              LDR      r2,[r4,#0x1c]
00001a  69a1              LDR      r1,[r4,#0x18]
00001c  f7fffffe          BL       DrvUSB_DataIn
;;;191    }
000020  bd70              POP      {r4-r6,pc}
;;;192    
                          ENDP

000022  0000              DCW      0x0000
                  |L10.36|
                          DCD      pfHID_GetInReport

                          AREA ||i.HID_IntOutCallback||, CODE, READONLY, ALIGN=2

                  HID_IntOutCallback PROC
;;;192    
;;;193    void HID_IntOutCallback(void * pVoid)
000000  b538              PUSH     {r3-r5,lr}
;;;194    {
000002  4605              MOV      r5,r0
;;;195        uint8_t *pu8EpBuf;
;;;196        uint32_t u32Size;
;;;197    
;;;198        pu8EpBuf = DrvUSB_GetOutData(HID_OUT_EP_NUM, &u32Size);
000004  4669              MOV      r1,sp
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       DrvUSB_GetOutData
00000c  4604              MOV      r4,r0
;;;199    
;;;200        if ((uint32_t)pfHID_SetOutReport)
00000e  4806              LDR      r0,|L11.40|
000010  6800              LDR      r0,[r0,#0]  ; pfHID_SetOutReport
000012  2800              CMP      r0,#0
000014  d003              BEQ      |L11.30|
;;;201            pfHID_SetOutReport(pu8EpBuf);
000016  4620              MOV      r0,r4
000018  4903              LDR      r1,|L11.40|
00001a  6809              LDR      r1,[r1,#0]  ; pfHID_SetOutReport
00001c  4788              BLX      r1
                  |L11.30|
;;;202    
;;;203        DrvUSB_DataOutTrigger(HID_OUT_EP_NUM, HID_MAX_PACKET_SIZE_EP2);
00001e  2140              MOVS     r1,#0x40
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       DrvUSB_DataOutTrigger
;;;204    }
000026  bd38              POP      {r3-r5,pc}
;;;205    
                          ENDP

                  |L11.40|
                          DCD      pfHID_SetOutReport

                          AREA ||i.HID_IsConfigureValue||, CODE, READONLY, ALIGN=2

                  HID_IsConfigureValue PROC
;;;287    /*************************************************************************/
;;;288    static int32_t HID_IsConfigureValue(uint8_t u8ConfigureValue)
000000  4601              MOV      r1,r0
;;;289    {
;;;290    	return (u8ConfigureValue == gau8ConfigDescriptor[5]);
000002  4804              LDR      r0,|L12.20|
000004  7940              LDRB     r0,[r0,#5]  ; gau8ConfigDescriptor
000006  4288              CMP      r0,r1
000008  d101              BNE      |L12.14|
00000a  2001              MOVS     r0,#1
                  |L12.12|
;;;291    }
00000c  4770              BX       lr
                  |L12.14|
00000e  2000              MOVS     r0,#0                 ;290
000010  e7fc              B        |L12.12|
;;;292    
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      gau8ConfigDescriptor

                          AREA ||i.HID_Open||, CODE, READONLY, ALIGN=2

                  HID_Open PROC
;;;120    /*************************************************************************/
;;;121    int32_t HID_Open(uint32_t inReportSize, void *pfGetInReport, void *pfSetOutReport)
000000  b5f8              PUSH     {r3-r7,lr}
;;;122    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;123    	int32_t i32Ret = E_SUCCESS;
000008  2700              MOVS     r7,#0
;;;124    
;;;125        if((uint32_t)pfGetInReport != NULL)
00000a  2c00              CMP      r4,#0
00000c  d001              BEQ      |L13.18|
;;;126            pfHID_GetInReport = (void(*)(uint8_t *))pfGetInReport;
00000e  4810              LDR      r0,|L13.80|
000010  6004              STR      r4,[r0,#0]  ; pfHID_GetInReport
                  |L13.18|
;;;127            
;;;128        if((uint32_t)pfSetOutReport != NULL)
000012  2d00              CMP      r5,#0
000014  d001              BEQ      |L13.26|
;;;129            pfHID_SetOutReport = (void(*)(uint8_t *))pfSetOutReport;
000016  480f              LDR      r0,|L13.84|
000018  6005              STR      r5,[r0,#0]  ; pfHID_SetOutReport
                  |L13.26|
;;;130    
;;;131    	g_HID_sDevice.device = (void *)DrvUSB_InstallClassDevice(&sHidUsbClass);
00001a  480f              LDR      r0,|L13.88|
00001c  f7fffffe          BL       DrvUSB_InstallClassDevice
000020  490e              LDR      r1,|L13.92|
000022  6248              STR      r0,[r1,#0x24]  ; g_HID_sDevice
;;;132    	
;;;133    	g_HID_sDevice.au8DeviceDescriptor = gau8DeviceDescriptor;
000024  480e              LDR      r0,|L13.96|
000026  6008              STR      r0,[r1,#0]  ; g_HID_sDevice
;;;134    	g_HID_sDevice.au8ConfigDescriptor = gau8ConfigDescriptor;
000028  480e              LDR      r0,|L13.100|
00002a  6048              STR      r0,[r1,#4]  ; g_HID_sDevice
;;;135    	g_HID_sDevice.pu8HIDDescriptor = g_HID_sDevice.au8ConfigDescriptor + LEN_CONFIG + LEN_INTERFACE;	
00002c  4608              MOV      r0,r1
00002e  6840              LDR      r0,[r0,#4]  ; g_HID_sDevice
000030  3012              ADDS     r0,r0,#0x12
000032  6148              STR      r0,[r1,#0x14]  ; g_HID_sDevice
;;;136    	g_HID_sDevice.pu8IntInEPDescriptor = g_HID_sDevice.au8ConfigDescriptor + LEN_CONFIG + LEN_INTERFACE + LEN_HID;
000034  4608              MOV      r0,r1
000036  6840              LDR      r0,[r0,#4]  ; g_HID_sDevice
000038  301b              ADDS     r0,r0,#0x1b
00003a  6088              STR      r0,[r1,#8]  ; g_HID_sDevice
;;;137    	
;;;138    	g_HID_sDevice.u32ReportSize = inReportSize;
00003c  4608              MOV      r0,r1
00003e  61c6              STR      r6,[r0,#0x1c]  ; g_HID_sDevice
;;;139    
;;;140    	
;;;141    	i32Ret = DrvUSB_InstallCtrlHandler(g_HID_sDevice.device, g_asCtrlCallbackEntry, 
000040  220d              MOVS     r2,#0xd
000042  6a48              LDR      r0,[r1,#0x24]  ; g_HID_sDevice
000044  4908              LDR      r1,|L13.104|
000046  f7fffffe          BL       DrvUSB_InstallCtrlHandler
00004a  4607              MOV      r7,r0
;;;142    					sizeof(g_asCtrlCallbackEntry) / sizeof(g_asCtrlCallbackEntry[0]));
;;;143    	return i32Ret;
00004c  4638              MOV      r0,r7
;;;144    }
00004e  bdf8              POP      {r3-r7,pc}
;;;145    
                          ENDP

                  |L13.80|
                          DCD      pfHID_GetInReport
                  |L13.84|
                          DCD      pfHID_SetOutReport
                  |L13.88|
                          DCD      sHidUsbClass
                  |L13.92|
                          DCD      g_HID_sDevice
                  |L13.96|
                          DCD      gau8DeviceDescriptor
                  |L13.100|
                          DCD      gau8ConfigDescriptor
                  |L13.104|
                          DCD      g_asCtrlCallbackEntry

                          AREA ||i.HID_PrepareDescriptors||, CODE, READONLY, ALIGN=2

                  HID_PrepareDescriptors PROC
;;;425    
;;;426    void HID_PrepareDescriptors(const uint8_t *pu8Descriptor, uint32_t u32DescriptorSize, uint32_t u32RequestSize, uint32_t u32MaxPacketSize)
000000  b5f8              PUSH     {r3-r7,lr}
;;;427    {
000002  4607              MOV      r7,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461c              MOV      r4,r3
;;;428        
;;;429        gu32BytesInUsbBuf = u32RequestSize;
00000a  4816              LDR      r0,|L14.100|
00000c  6006              STR      r6,[r0,#0]  ; gu32BytesInUsbBuf
;;;430        if(u32RequestSize > u32DescriptorSize)
00000e  42ae              CMP      r6,r5
000010  d903              BLS      |L14.26|
;;;431        {
;;;432            gu32BytesInUsbBuf = u32DescriptorSize;
000012  6005              STR      r5,[r0,#0]  ; gu32BytesInUsbBuf
;;;433            gIsOverRequest = 1;
000014  2001              MOVS     r0,#1
000016  4914              LDR      r1,|L14.104|
000018  7008              STRB     r0,[r1,#0]
                  |L14.26|
;;;434        }
;;;435        gpu8UsbBuf = pu8Descriptor;
00001a  4814              LDR      r0,|L14.108|
00001c  6007              STR      r7,[r0,#0]  ; gpu8UsbBuf
;;;436    
;;;437        DBG_PRINTF("Get descriptor 0x%08x %d size.\n", pu8Descriptor, u32DescriptorSize);
;;;438    
;;;439    	if(gu32BytesInUsbBuf < u32MaxPacketSize)
00001e  4811              LDR      r0,|L14.100|
000020  6800              LDR      r0,[r0,#0]  ; gu32BytesInUsbBuf
000022  42a0              CMP      r0,r4
000024  d20c              BCS      |L14.64|
;;;440    	{
;;;441    	    DrvUSB_DataIn(0, gpu8UsbBuf, gu32BytesInUsbBuf); 
000026  480f              LDR      r0,|L14.100|
000028  6802              LDR      r2,[r0,#0]  ; gu32BytesInUsbBuf
00002a  4810              LDR      r0,|L14.108|
00002c  6801              LDR      r1,[r0,#0]  ; gpu8UsbBuf
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       DrvUSB_DataIn
;;;442    	    gpu8UsbBuf = 0;
000034  2000              MOVS     r0,#0
000036  490d              LDR      r1,|L14.108|
000038  6008              STR      r0,[r1,#0]  ; gpu8UsbBuf
;;;443    	    gu32BytesInUsbBuf = 0;   
00003a  490a              LDR      r1,|L14.100|
00003c  6008              STR      r0,[r1,#0]  ; gu32BytesInUsbBuf
00003e  e00f              B        |L14.96|
                  |L14.64|
;;;444    	}
;;;445    	else
;;;446    	{
;;;447    		DrvUSB_DataIn(0, gpu8UsbBuf, u32MaxPacketSize);
000040  4622              MOV      r2,r4
000042  480a              LDR      r0,|L14.108|
000044  6801              LDR      r1,[r0,#0]  ; gpu8UsbBuf
000046  2000              MOVS     r0,#0
000048  f7fffffe          BL       DrvUSB_DataIn
;;;448    		gpu8UsbBuf += u32MaxPacketSize;
00004c  4807              LDR      r0,|L14.108|
00004e  6800              LDR      r0,[r0,#0]  ; gpu8UsbBuf
000050  1900              ADDS     r0,r0,r4
000052  4906              LDR      r1,|L14.108|
000054  6008              STR      r0,[r1,#0]  ; gpu8UsbBuf
;;;449    		gu32BytesInUsbBuf -= u32MaxPacketSize;
000056  4803              LDR      r0,|L14.100|
000058  6800              LDR      r0,[r0,#0]  ; gu32BytesInUsbBuf
00005a  1b00              SUBS     r0,r0,r4
00005c  4901              LDR      r1,|L14.100|
00005e  6008              STR      r0,[r1,#0]  ; gu32BytesInUsbBuf
                  |L14.96|
;;;450        }
;;;451    
;;;452    }
000060  bdf8              POP      {r3-r7,pc}
;;;453    
                          ENDP

000062  0000              DCW      0x0000
                  |L14.100|
                          DCD      gu32BytesInUsbBuf
                  |L14.104|
                          DCD      gIsOverRequest
                  |L14.108|
                          DCD      gpu8UsbBuf

                          AREA ||i.HID_Reset||, CODE, READONLY, ALIGN=1

                  HID_Reset PROC
;;;155    
;;;156    static void HID_Reset(S_HID_DEVICE *psDevice)
000000  b510              PUSH     {r4,lr}
;;;157    {	
000002  4604              MOV      r4,r0
;;;158    	DrvUSB_Reset(HID_IN_EP_NUM);
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       DrvUSB_Reset
;;;159    	DrvUSB_Reset(HID_OUT_EP_NUM);
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       DrvUSB_Reset
;;;160     }
000010  bd10              POP      {r4,pc}
;;;161    
                          ENDP


                          AREA ||i.HID_SetReportBuf||, CODE, READONLY, ALIGN=2

                  HID_SetReportBuf PROC
;;;254    /*************************************************************************/
;;;255    int32_t HID_SetReportBuf(uint8_t* pu8Report, uint32_t u32ReportSize)
000000  4602              MOV      r2,r0
;;;256    {
;;;257    	if (pu8Report == NULL)
000002  2a00              CMP      r2,#0
000004  d101              BNE      |L16.10|
;;;258    	{
;;;259    		return (E_HID_NULL_POINTER);
000006  4806              LDR      r0,|L16.32|
                  |L16.8|
;;;260    	}
;;;261    	if (u32ReportSize > HID_MAX_PACKET_SIZE_EP1)
;;;262    	{
;;;263    		return (E_HID_EXCEED_INT_IN_PACKET_SIZE);
;;;264    	}
;;;265    
;;;266    	g_HID_sDevice.pu8Report = pu8Report;
;;;267    	g_HID_sDevice.u32ReportSize = u32ReportSize;
;;;268    
;;;269    	return E_SUCCESS;
;;;270    }
000008  4770              BX       lr
                  |L16.10|
00000a  2940              CMP      r1,#0x40              ;261
00000c  d902              BLS      |L16.20|
00000e  4804              LDR      r0,|L16.32|
000010  1d00              ADDS     r0,r0,#4              ;263
000012  e7f9              B        |L16.8|
                  |L16.20|
000014  4803              LDR      r0,|L16.36|
000016  6182              STR      r2,[r0,#0x18]         ;266  ; g_HID_sDevice
000018  61c1              STR      r1,[r0,#0x1c]         ;267  ; g_HID_sDevice
00001a  2000              MOVS     r0,#0                 ;269
00001c  e7f4              B        |L16.8|
;;;271    
                          ENDP

00001e  0000              DCW      0x0000
                  |L16.32|
                          DCD      0xffffee01
                  |L16.36|
                          DCD      g_HID_sDevice

                          AREA ||i.HID_SetReportDescriptor||, CODE, READONLY, ALIGN=2

                  HID_SetReportDescriptor PROC
;;;223    /*************************************************************************/
;;;224    int32_t HID_SetReportDescriptor(const uint8_t* pu8ReportDescriptor, uint32_t u32ReportDescriptorSize)
000000  4602              MOV      r2,r0
;;;225    {
;;;226    	if (pu8ReportDescriptor == NULL)
000002  2a00              CMP      r2,#0
000004  d101              BNE      |L17.10|
;;;227    	{
;;;228    		return (E_HID_NULL_POINTER);
000006  4803              LDR      r0,|L17.20|
                  |L17.8|
;;;229    	}
;;;230    
;;;231    	g_HID_sDevice.pu8ReportDescriptor = pu8ReportDescriptor;
;;;232    	g_HID_sDevice.u32ReportDescriptorSize = u32ReportDescriptorSize;
;;;233    	
;;;234    	return E_SUCCESS;
;;;235    }
000008  4770              BX       lr
                  |L17.10|
00000a  4803              LDR      r0,|L17.24|
00000c  60c2              STR      r2,[r0,#0xc]          ;231  ; g_HID_sDevice
00000e  6101              STR      r1,[r0,#0x10]         ;232  ; g_HID_sDevice
000010  2000              MOVS     r0,#0                 ;234
000012  e7f9              B        |L17.8|
;;;236    
                          ENDP

                  |L17.20|
                          DCD      0xffffee01
                  |L17.24|
                          DCD      g_HID_sDevice

                          AREA ||i.HID_Start||, CODE, READONLY, ALIGN=1

                  HID_Start PROC
;;;161    
;;;162    void HID_Start(S_HID_DEVICE *psDevice)
000000  b510              PUSH     {r4,lr}
;;;163    {
000002  4604              MOV      r4,r0
;;;164    	DrvUSB_DataIn(HID_IN_EP_NUM, psDevice->pu8Report, psDevice->u32ReportSize);
000004  2001              MOVS     r0,#1
000006  69e2              LDR      r2,[r4,#0x1c]
000008  69a1              LDR      r1,[r4,#0x18]
00000a  f7fffffe          BL       DrvUSB_DataIn
;;;165       	DrvUSB_DataOutTrigger(HID_OUT_EP_NUM, HID_MAX_PACKET_SIZE_EP2);
00000e  2140              MOVS     r1,#0x40
000010  2002              MOVS     r0,#2
000012  f7fffffe          BL       DrvUSB_DataOutTrigger
;;;166    }
000016  bd10              POP      {r4,pc}
;;;167    
                          ENDP


                          AREA ||i.HID_UsbStartCallBack||, CODE, READONLY, ALIGN=1

                  HID_UsbStartCallBack PROC
;;;149    
;;;150    static void HID_UsbStartCallBack(void * pVoid)
000000  b510              PUSH     {r4,lr}
;;;151    {
000002  4604              MOV      r4,r0
;;;152    	HID_Reset((S_HID_DEVICE *)pVoid);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       HID_Reset
;;;153    	HID_Start((S_HID_DEVICE *)pVoid);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       HID_Start
;;;154    }
000010  bd10              POP      {r4,pc}
;;;155    
                          ENDP


                          AREA ||i._HID_CLR_CTRL_READY||, CODE, READONLY, ALIGN=2

                  _HID_CLR_CTRL_READY PROC
;;;94     
;;;95     static void _HID_CLR_CTRL_READY()
000000  4806              LDR      r0,|L20.28|
;;;96     {
;;;97     	_DRVUSB_CLEAR_EP_READY(0);
000002  6ac0              LDR      r0,[r0,#0x2c]
000004  2101              MOVS     r1,#1
000006  4308              ORRS     r0,r0,r1
000008  4904              LDR      r1,|L20.28|
00000a  62c8              STR      r0,[r1,#0x2c]
;;;98     	_DRVUSB_CLEAR_EP_READY(1);
00000c  4608              MOV      r0,r1
00000e  6bc0              LDR      r0,[r0,#0x3c]
000010  2101              MOVS     r1,#1
000012  4308              ORRS     r0,r0,r1
000014  4901              LDR      r1,|L20.28|
000016  63c8              STR      r0,[r1,#0x3c]
;;;99     }
000018  4770              BX       lr
;;;100    
                          ENDP

00001a  0000              DCW      0x0000
                  |L20.28|
                          DCD      0x40060000

                          AREA ||i._HID_CLR_CTRL_READY_AND_TRIG_STALL||, CODE, READONLY, ALIGN=2

                  _HID_CLR_CTRL_READY_AND_TRIG_STALL PROC
;;;88     
;;;89     static void _HID_CLR_CTRL_READY_AND_TRIG_STALL()
000000  4806              LDR      r0,|L21.28|
;;;90     {
;;;91     	_DRVUSB_CLEAR_EP_READY_AND_TRIG_STALL(0);
000002  6ac0              LDR      r0,[r0,#0x2c]
000004  2103              MOVS     r1,#3
000006  4308              ORRS     r0,r0,r1
000008  4904              LDR      r1,|L21.28|
00000a  62c8              STR      r0,[r1,#0x2c]
;;;92     	_DRVUSB_CLEAR_EP_READY_AND_TRIG_STALL(1);
00000c  4608              MOV      r0,r1
00000e  6bc0              LDR      r0,[r0,#0x3c]
000010  2103              MOVS     r1,#3
000012  4308              ORRS     r0,r0,r1
000014  4901              LDR      r1,|L21.28|
000016  63c8              STR      r0,[r1,#0x3c]
;;;93     }
000018  4770              BX       lr
;;;94     
                          ENDP

00001a  0000              DCW      0x0000
                  |L21.28|
                          DCD      0x40060000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_HID_sDevice
                          %        40

                          AREA ||.data||, DATA, ALIGN=2

                  sEpDescription
                          DCD      0x00000080
                          DCD      0x00000040
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000040
                          DCD      0x00000000
                          DCD      0x00000081
                          DCD      0x00000040
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x00000040
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                  g_sBusOps
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      DrvUSB_BusResetCallback
                          DCD      g_HID_sDevice
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      DrvUSB_CtrlSetupAck
                          DCD      g_HID_sDevice
                  g_sUsbOps
                          DCD      DrvUSB_CtrlDataInAck
                          DCD      g_HID_sDevice
                          DCD      DrvUSB_CtrlDataOutAck
                          DCD      g_HID_sDevice
                          DCD      HID_IntInCallback
                          DCD      g_HID_sDevice
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      HID_IntOutCallback
                          DCD      g_HID_sDevice
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                  g_asCtrlCallbackEntry
0000cc  00050000          DCB      0x00,0x05,0x00,0x00
                          DCD      DrvUSB_CtrlSetupSetAddress
                          DCD      DrvUSB_CtrlDataInSetAddress
                          DCD      0x00000000
                          DCD      g_HID_sDevice
0000e0  00010000          DCB      0x00,0x01,0x00,0x00
                          DCD      DrvUSB_CtrlSetupClearSetFeature
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      g_HID_sDevice
0000f4  00030000          DCB      0x00,0x03,0x00,0x00
                          DCD      DrvUSB_CtrlSetupClearSetFeature
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      g_HID_sDevice
000108  00080000          DCB      0x00,0x08,0x00,0x00
                          DCD      DrvUSB_CtrlSetupGetConfiguration
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      g_HID_sDevice
00011c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      DrvUSB_CtrlSetupGetStatus
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      g_HID_sDevice
000130  000a0000          DCB      0x00,0x0a,0x00,0x00
                          DCD      DrvUSB_CtrlSetupGetInterface
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      g_HID_sDevice
000144  000b0000          DCB      0x00,0x0b,0x00,0x00
                          DCD      DrvUSB_CtrlSetupSetInterface
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      g_HID_sDevice
000158  00060000          DCB      0x00,0x06,0x00,0x00
                          DCD      HID_CtrlSetupGetDescriptor
                          DCD      HID_CtrlGetDescriptorIn
                          DCD      HID_CtrlGetDescriptorOut
                          DCD      g_HID_sDevice
00016c  00090000          DCB      0x00,0x09,0x00,0x00
                          DCD      DrvUSB_CtrlSetupSetConfiguration
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      g_HID_sDevice
000180  20010000          DCB      0x20,0x01,0x00,0x00
                          DCD      HID_CtrlSetupGetReport
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      g_HID_sDevice
000194  20090000          DCB      0x20,0x09,0x00,0x00
                          DCD      HID_CtrlSetupSetReport
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      g_HID_sDevice
0001a8  200a0000          DCB      0x20,0x0a,0x00,0x00
                          DCD      HID_CtrlSetupSetIdle
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      g_HID_sDevice
0001bc  200b0000          DCB      0x20,0x0b,0x00,0x00
                          DCD      HID_CtrlSetupSetProtocol
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      g_HID_sDevice
                  pfHID_GetInReport
                          DCD      0x00000000
                  pfHID_SetOutReport
                          DCD      0x00000000
                  sHidUsbClass
                          DCD      g_HID_sDevice
                          DCD      HID_UsbStartCallBack
                          DCD      HID_IsConfigureValue
                          DCD      0x00000000
                  gpu8UsbBuf
                          DCD      0x00000000
                  gu32BytesInUsbBuf
                          DCD      0x00000000
                  gIsOverRequest
0001f0  00                DCB      0x00
