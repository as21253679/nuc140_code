; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\hid_api.o --depend=.\obj\hid_api.d --feedback=.\obj\Smpl_HID_IO.fed --cpu=Cortex-M0 --apcs=interwork -O0 -I.\ -I..\..\..\..\CMSIS\CM0\CoreSupport -I..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx -I..\..\..\Include -I..\..\..\Include\Driver -I..\..\..\Include\NUC1xx-LB_002 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\obj\hid_api.crf HID_API.c]
                          THUMB

                          AREA ||i.HID_GetInReport||, CODE, READONLY, ALIGN=1

                  HID_GetInReport PROC
;;;221    
;;;222    void HID_GetInReport(uint8_t *buf)
000000  4770              BX       lr
;;;223    {
;;;224    
;;;225    }
;;;226    
                          ENDP


                          AREA ||i.HID_Init||, CODE, READONLY, ALIGN=2

                  HID_Init PROC
;;;190    
;;;191    void HID_Init(void *pfGetInReport, void *pfSetOutReport)
000000  b570              PUSH     {r4-r6,lr}
;;;192    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;193        /* Open HID to initial the descriptors and control handlers */
;;;194        HID_Open(HID_REPORT_SIZE, pfGetInReport, pfSetOutReport);
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2040              MOVS     r0,#0x40
00000c  f7fffffe          BL       HID_Open
;;;195    
;;;196        /* Set the HID report descriptor */
;;;197        HID_SetReportDescriptor(g_HID_au8DeviceReportDescriptor, g_HID_u32DeviceReportDescriptorSize);
000010  211b              MOVS     r1,#0x1b
000012  4804              LDR      r0,|L2.36|
000014  f7fffffe          BL       HID_SetReportDescriptor
;;;198    
;;;199        /* Set the HID report buffer */
;;;200        HID_SetReportBuf(g_au8DeviceReport, g_u32DeviceReportSize);
000018  2140              MOVS     r1,#0x40
00001a  4803              LDR      r0,|L2.40|
00001c  f7fffffe          BL       HID_SetReportBuf
;;;201    }
000020  bd70              POP      {r4-r6,pc}
;;;202    
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      g_HID_au8DeviceReportDescriptor
                  |L2.40|
                          DCD      g_au8DeviceReport

                          AREA ||i.HID_MainProcess||, CODE, READONLY, ALIGN=2

                  HID_MainProcess PROC
;;;240    
;;;241    int32_t HID_MainProcess(void)
000000  b570              PUSH     {r4-r6,lr}
;;;242    {
;;;243        int32_t i32Ret = E_SUCCESS;
000002  2500              MOVS     r5,#0
;;;244    	E_DRVUSB_STATE eUsbState;
;;;245    	    
;;;246        i32Ret = DrvUSB_Open((void *)DrvUSB_DispatchEvent);
000004  4825              LDR      r0,|L3.156|
000006  f7fffffe          BL       DrvUSB_Open
00000a  4605              MOV      r5,r0
;;;247    
;;;248        if(i32Ret != E_SUCCESS)
00000c  2d00              CMP      r5,#0
00000e  d001              BEQ      |L3.20|
;;;249            return i32Ret;
000010  4628              MOV      r0,r5
;;;250    
;;;251        eUsbState = DrvUSB_GetUsbState();
;;;252        
;;;253        if (eUsbState >= eDRVUSB_ATTACHED)
;;;254        {
;;;255            _DRVUSB_ENABLE_SE0();
;;;256            Delay(1000);
;;;257            _DRVUSB_DISABLE_SE0();
;;;258        }
;;;259    
;;;260    	while(1)
;;;261    	{
;;;262    		/* Disable USB-related interrupts. */
;;;263    		_DRVUSB_ENABLE_MISC_INT(0);
;;;264    
;;;265    		/* Enable float-detection interrupt. */
;;;266    		_DRVUSB_ENABLE_FLDET_INT();
;;;267    
;;;268    		// Wait for USB connected.
;;;269    		while (1)
;;;270    		{
;;;271    			// Order here is significant.
;;;272    			// Give a chance to handle remaining events before exiting this loop.
;;;273    			eUsbState = DrvUSB_GetUsbState();
;;;274    
;;;275    			//DrvUSB_DispatchEvent();
;;;276    
;;;277    			if (eUsbState >= eDRVUSB_ATTACHED &&
;;;278    			        eUsbState != eDRVUSB_SUSPENDED)
;;;279    			{
;;;280    				break;
;;;281    			}
;;;282    		}
;;;283    		
;;;284    		/* Start HID and install the callback functions to handle in/out report */
;;;285    		HID_Init((void *)HID_GetInReport, (void *)HID_SetOutReport);
;;;286    
;;;287    		// Enable USB-related interrupts.
;;;288    		_DRVUSB_ENABLE_MISC_INT(INTEN_WAKEUP | INTEN_WAKEUPEN | INTEN_FLDET | INTEN_USB | INTEN_BUS);
;;;289    
;;;290    		// Poll and handle USB events.
;;;291    		while(1)
;;;292    		{
;;;293    			eUsbState = DrvUSB_GetUsbState();
;;;294    		
;;;295    			if (eUsbState == eDRVUSB_DETACHED)
;;;296    			{
;;;297    				break;
;;;298    			}
;;;299    		}
;;;300    
;;;301    		// Disable USB-related interrupts.
;;;302    		_DRVUSB_ENABLE_MISC_INT(0);
;;;303        }
;;;304    }
000012  bd70              POP      {r4-r6,pc}
                  |L3.20|
000014  f7fffffe          BL       DrvUSB_GetUsbState
000018  4604              MOV      r4,r0                 ;251
00001a  2c01              CMP      r4,#1                 ;253
00001c  db10              BLT      |L3.64|
00001e  4820              LDR      r0,|L3.160|
000020  6900              LDR      r0,[r0,#0x10]         ;255
000022  0840              LSRS     r0,r0,#1              ;255
000024  0040              LSLS     r0,r0,#1              ;255
000026  1c40              ADDS     r0,r0,#1              ;255
000028  491d              LDR      r1,|L3.160|
00002a  6108              STR      r0,[r1,#0x10]         ;255
00002c  207d              MOVS     r0,#0x7d              ;256
00002e  00c0              LSLS     r0,r0,#3              ;256
000030  f7fffffe          BL       Delay
000034  481a              LDR      r0,|L3.160|
000036  6900              LDR      r0,[r0,#0x10]         ;257
000038  0840              LSRS     r0,r0,#1              ;257
00003a  0040              LSLS     r0,r0,#1              ;257
00003c  4918              LDR      r1,|L3.160|
00003e  6108              STR      r0,[r1,#0x10]         ;257
                  |L3.64|
000040  e02b              B        |L3.154|
                  |L3.66|
000042  2000              MOVS     r0,#0                 ;263
000044  4916              LDR      r1,|L3.160|
000046  3980              SUBS     r1,r1,#0x80           ;263
000048  6008              STR      r0,[r1,#0]            ;263
00004a  4608              MOV      r0,r1                 ;266
00004c  6800              LDR      r0,[r0,#0]            ;266
00004e  2104              MOVS     r1,#4                 ;266
000050  4388              BICS     r0,r0,r1              ;266
000052  1d00              ADDS     r0,r0,#4              ;266
000054  4912              LDR      r1,|L3.160|
000056  3980              SUBS     r1,r1,#0x80           ;266
000058  6008              STR      r0,[r1,#0]            ;266
00005a  e007              B        |L3.108|
                  |L3.92|
00005c  f7fffffe          BL       DrvUSB_GetUsbState
000060  4604              MOV      r4,r0                 ;273
000062  2c01              CMP      r4,#1                 ;277
000064  db02              BLT      |L3.108|
000066  2c20              CMP      r4,#0x20              ;278
000068  d000              BEQ      |L3.108|
00006a  e000              B        |L3.110|
                  |L3.108|
00006c  e7f6              B        |L3.92|
                  |L3.110|
00006e  bf00              NOP                            ;280
000070  490c              LDR      r1,|L3.164|
000072  480d              LDR      r0,|L3.168|
000074  f7fffffe          BL       HID_Init
000078  200f              MOVS     r0,#0xf               ;288
00007a  4909              LDR      r1,|L3.160|
00007c  3980              SUBS     r1,r1,#0x80           ;288
00007e  6008              STR      r0,[r1,#0]            ;288
000080  e005              B        |L3.142|
                  |L3.130|
000082  f7fffffe          BL       DrvUSB_GetUsbState
000086  4604              MOV      r4,r0                 ;293
000088  2c00              CMP      r4,#0                 ;295
00008a  d100              BNE      |L3.142|
00008c  e000              B        |L3.144|
                  |L3.142|
00008e  e7f8              B        |L3.130|
                  |L3.144|
000090  bf00              NOP                            ;297
000092  2000              MOVS     r0,#0                 ;302
000094  4902              LDR      r1,|L3.160|
000096  3980              SUBS     r1,r1,#0x80           ;302
000098  6008              STR      r0,[r1,#0]            ;302
                  |L3.154|
00009a  e7d2              B        |L3.66|
                          ENDP

                  |L3.156|
                          DCD      DrvUSB_DispatchEvent
                  |L3.160|
                          DCD      0x40060080
                  |L3.164|
                          DCD      HID_SetOutReport
                  |L3.168|
                          DCD      HID_GetInReport

                          AREA ||i.HID_SetOutReport||, CODE, READONLY, ALIGN=2

                  HID_SetOutReport PROC
;;;228       report. */
;;;229    void HID_SetOutReport(uint8_t *pu8EpBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;230    {
000002  4604              MOV      r4,r0
;;;231        uint32_t u32Size = (uint32_t)pu8EpBuf[1];
000004  7865              LDRB     r5,[r4,#1]
;;;232    
;;;233        //Set new index
;;;234        g_u8CmdIndex = pu8EpBuf[0];
000006  7820              LDRB     r0,[r4,#0]
000008  4903              LDR      r1,|L4.24|
00000a  7008              STRB     r0,[r1,#0]
;;;235    
;;;236        V6M_ProcessCommand((uint8_t *)&pu8EpBuf[2], u32Size);									 
00000c  4629              MOV      r1,r5
00000e  1ca0              ADDS     r0,r4,#2
000010  f7fffffe          BL       V6M_ProcessCommand
;;;237    }
000014  bd70              POP      {r4-r6,pc}
;;;238    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      g_u8CmdIndex

                          AREA ||i.USB_SendBackData||, CODE, READONLY, ALIGN=2

                  USB_SendBackData PROC
;;;205    static uint8_t g_u8CmdIndex = 0;
;;;206    void USB_SendBackData(uint8_t bError, const uint8_t *pu8Buffer, uint32_t u32Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;207    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
000006  4614              MOV      r4,r2
;;;208        uint8_t *pu8EpBuf;
;;;209    
;;;210        pu8EpBuf = (uint8_t *) & g_au8DeviceReport;
000008  4d0a              LDR      r5,|L5.52|
;;;211        if (u32Size > sizeof(g_au8DeviceReport))
00000a  2c40              CMP      r4,#0x40
00000c  d900              BLS      |L5.16|
;;;212            u32Size = sizeof(g_au8DeviceReport);
00000e  2440              MOVS     r4,#0x40
                  |L5.16|
;;;213    
;;;214        pu8EpBuf[0] = (g_u8CmdIndex & (uint8_t)0x7F) | (bError ? (uint8_t)0x80 : (uint8_t)0x00);
000010  4809              LDR      r0,|L5.56|
000012  7800              LDRB     r0,[r0,#0]  ; g_u8CmdIndex
000014  0640              LSLS     r0,r0,#25
000016  0e40              LSRS     r0,r0,#25
000018  2e00              CMP      r6,#0
00001a  d001              BEQ      |L5.32|
00001c  2180              MOVS     r1,#0x80
00001e  e000              B        |L5.34|
                  |L5.32|
000020  2100              MOVS     r1,#0
                  |L5.34|
000022  4308              ORRS     r0,r0,r1
000024  7028              STRB     r0,[r5,#0]
;;;215        pu8EpBuf[1] = (uint8_t)u32Size;
000026  706c              STRB     r4,[r5,#1]
;;;216        memcpy(&pu8EpBuf[2], pu8Buffer, u32Size);
000028  4622              MOV      r2,r4
00002a  4639              MOV      r1,r7
00002c  1ca8              ADDS     r0,r5,#2
00002e  f7fffffe          BL       __aeabi_memcpy
;;;217    }
000032  bdf8              POP      {r3-r7,pc}
;;;218    
                          ENDP

                  |L5.52|
                          DCD      g_au8DeviceReport
                  |L5.56|
                          DCD      g_u8CmdIndex

                          AREA ||i._HID_CLR_CTRL_READY||, CODE, READONLY, ALIGN=2

                  _HID_CLR_CTRL_READY PROC
;;;94     
;;;95     static void _HID_CLR_CTRL_READY()
000000  4806              LDR      r0,|L6.28|
;;;96     {
;;;97     	_DRVUSB_CLEAR_EP_READY(0);
000002  6ac0              LDR      r0,[r0,#0x2c]
000004  2101              MOVS     r1,#1
000006  4308              ORRS     r0,r0,r1
000008  4904              LDR      r1,|L6.28|
00000a  62c8              STR      r0,[r1,#0x2c]
;;;98     	_DRVUSB_CLEAR_EP_READY(1);
00000c  4608              MOV      r0,r1
00000e  6bc0              LDR      r0,[r0,#0x3c]
000010  2101              MOVS     r1,#1
000012  4308              ORRS     r0,r0,r1
000014  4901              LDR      r1,|L6.28|
000016  63c8              STR      r0,[r1,#0x3c]
;;;99     }
000018  4770              BX       lr
;;;100    
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x40060000

                          AREA ||i._HID_CLR_CTRL_READY_AND_TRIG_STALL||, CODE, READONLY, ALIGN=2

                  _HID_CLR_CTRL_READY_AND_TRIG_STALL PROC
;;;88     
;;;89     static void _HID_CLR_CTRL_READY_AND_TRIG_STALL()
000000  4806              LDR      r0,|L7.28|
;;;90     {
;;;91     	_DRVUSB_CLEAR_EP_READY_AND_TRIG_STALL(0);
000002  6ac0              LDR      r0,[r0,#0x2c]
000004  2103              MOVS     r1,#3
000006  4308              ORRS     r0,r0,r1
000008  4904              LDR      r1,|L7.28|
00000a  62c8              STR      r0,[r1,#0x2c]
;;;92     	_DRVUSB_CLEAR_EP_READY_AND_TRIG_STALL(1);
00000c  4608              MOV      r0,r1
00000e  6bc0              LDR      r0,[r0,#0x3c]
000010  2103              MOVS     r1,#3
000012  4308              ORRS     r0,r0,r1
000014  4901              LDR      r1,|L7.28|
000016  63c8              STR      r0,[r1,#0x3c]
;;;93     }
000018  4770              BX       lr
;;;94     
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x40060000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_au8DeviceReport
                          %        64

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_HID_au8DeviceReportDescriptor
000000  05010900          DCB      0x05,0x01,0x09,0x00
000004  a1011500          DCB      0xa1,0x01,0x15,0x00
000008  25ff1901          DCB      0x25,0xff,0x19,0x01
00000c  29089540          DCB      0x29,0x08,0x95,0x40
000010  75088102          DCB      0x75,0x08,0x81,0x02
000014  19012908          DCB      0x19,0x01,0x29,0x08
000018  9102c000          DCB      0x91,0x02,0xc0,0x00
                  g_HID_u32DeviceReportDescriptorSize
                          DCD      0x0000001b
                  gau8DeviceDescriptor
000020  12011001          DCB      0x12,0x01,0x10,0x01
000024  00000040          DCB      0x00,0x00,0x00,0x40
000028  1a051b51          DCB      0x1a,0x05,0x1b,0x51
00002c  00000102          DCB      0x00,0x00,0x01,0x02
000030  0301              DCB      0x03,0x01
                  gau8ConfigDescriptor
000032  0902              DCB      0x09,0x02
000034  29000101          DCB      0x29,0x00,0x01,0x01
000038  00803209          DCB      0x00,0x80,0x32,0x09
00003c  04000002          DCB      0x04,0x00,0x00,0x02
000040  03000000          DCB      0x03,0x00,0x00,0x00
000044  09211001          DCB      0x09,0x21,0x10,0x01
000048  0001221b          DCB      0x00,0x01,0x22,0x1b
00004c  00070581          DCB      0x00,0x07,0x05,0x81
000050  03400001          DCB      0x03,0x40,0x00,0x01
000054  07050203          DCB      0x07,0x05,0x02,0x03
000058  400001            DCB      0x40,0x00,0x01
                  gau8StringLang
00005b  04                DCB      0x04
00005c  030904            DCB      0x03,0x09,0x04
                  gau8VendorStringDescriptor
00005f  10                DCB      0x10
000060  034e0055          DCB      0x03,0x4e,0x00,0x55
000064  0056004f          DCB      0x00,0x56,0x00,0x4f
000068  0054004f          DCB      0x00,0x54,0x00,0x4f
00006c  004e00            DCB      0x00,0x4e,0x00
                  gau8ProductStringDescriptor
00006f  16                DCB      0x16
000070  03550053          DCB      0x03,0x55,0x00,0x53
000074  00420020          DCB      0x00,0x42,0x00,0x20
000078  00480049          DCB      0x00,0x48,0x00,0x49
00007c  00440020          DCB      0x00,0x44,0x00,0x20
000080  0049004f          DCB      0x00,0x49,0x00,0x4f
000084  00                DCB      0x00
                  gau8StringSerial
000085  1a0342            DCB      0x1a,0x03,0x42
000088  00300032          DCB      0x00,0x30,0x00,0x32
00008c  00300030          DCB      0x00,0x30,0x00,0x30
000090  00360030          DCB      0x00,0x36,0x00,0x30
000094  00390032          DCB      0x00,0x39,0x00,0x32
000098  00310031          DCB      0x00,0x31,0x00,0x31
00009c  003400            DCB      0x00,0x34,0x00

                          AREA ||.data||, DATA, ALIGN=0

                  g_u8CmdIndex
000000  00                DCB      0x00
